From 84f7778808b7fee771f26c3cae46292ef85f06c0 Mon Sep 17 00:00:00 2001
From: Rajasekar Raja <rajasekarr@nvidia.com>
Date: Thu, 15 Feb 2024 11:23:51 -0800
Subject: [PATCH 07/11] bgpd : backpressure - Handle BGP-Zebra(EPVN) Install
 evt Creation

Current changes deals with EVPN routes installation to zebra.

In evpn_route_select_install() we invoke evpn_zebra_install/uninstall
which sends zclient_send_message().

This is a continuation of code changes (similar to
ccfe452763d16c432fa81fd20e805bec819b345e) but to handle evpn part
of the code.

Ticket: #3390099

Signed-off-by: Rajasekar Raja <rajasekarr@nvidia.com>

diff --git a/bgpd/bgp_evpn.c b/bgpd/bgp_evpn.c
index a846484f0..79e16d8f9 100644
--- a/bgpd/bgp_evpn.c
+++ b/bgpd/bgp_evpn.c
@@ -55,27 +55,25 @@ DEFINE_MTYPE_STATIC(BGPD, VRF_ROUTE_TARGET, "L3 Route Target");
 /*
  * Static function declarations
  */
-static void bgp_evpn_remote_ip_hash_init(struct bgpevpn *evpn);
-static void bgp_evpn_remote_ip_hash_destroy(struct bgpevpn *evpn);
-static void bgp_evpn_remote_ip_hash_add(struct bgpevpn *vpn,
+void bgp_evpn_remote_ip_hash_init(struct bgpevpn *evpn);
+void bgp_evpn_remote_ip_hash_destroy(struct bgpevpn *evpn);
+void bgp_evpn_remote_ip_hash_add(struct bgpevpn *vpn,
 					struct bgp_path_info *pi);
-static void bgp_evpn_remote_ip_hash_del(struct bgpevpn *vpn,
+void bgp_evpn_remote_ip_hash_del(struct bgpevpn *vpn,
 					struct bgp_path_info *pi);
-static void bgp_evpn_remote_ip_hash_iterate(struct bgpevpn *vpn,
-					    void (*func)(struct hash_bucket *,
-							 void *),
-					    void *arg);
-static void bgp_evpn_link_to_vni_svi_hash(struct bgp *bgp, struct bgpevpn *vpn);
-static void bgp_evpn_unlink_from_vni_svi_hash(struct bgp *bgp,
+void bgp_evpn_remote_ip_hash_iterate(struct bgpevpn *vpn,
+					    void (*func)(struct hash_bucket *,void *), void *arg);
+void bgp_evpn_link_to_vni_svi_hash(struct bgp *bgp, struct bgpevpn *vpn);
+void bgp_evpn_unlink_from_vni_svi_hash(struct bgp *bgp,
 					      struct bgpevpn *vpn);
-static unsigned int vni_svi_hash_key_make(const void *p);
-static bool vni_svi_hash_cmp(const void *p1, const void *p2);
-static void bgp_evpn_remote_ip_process_nexthops(struct bgpevpn *vpn,
+unsigned int  vni_svi_hash_key_make(const void *p);
+bool vni_svi_hash_cmp(const void *p1, const void *p2);
+void bgp_evpn_remote_ip_process_nexthops(struct bgpevpn *vpn,
 						struct ipaddr *addr,
 						bool resolve);
-static void bgp_evpn_remote_ip_hash_link_nexthop(struct hash_bucket *bucket,
+void bgp_evpn_remote_ip_hash_link_nexthop(struct hash_bucket *bucket,
 						 void *args);
-static void bgp_evpn_remote_ip_hash_unlink_nexthop(struct hash_bucket *bucket,
+void bgp_evpn_remote_ip_hash_unlink_nexthop(struct hash_bucket *bucket,
 						   void *args);
 static struct in_addr zero_vtep_ip;

@@ -86,7 +84,7 @@ static struct in_addr zero_vtep_ip;
 /*
  * Make vni hash key.
  */
-static unsigned int vni_hash_key_make(const void *p)
+unsigned int  vni_hash_key_make(const void *p)
 {
 	const struct bgpevpn *vpn = p;
 	return (jhash_1word(vpn->vni, 0));
@@ -95,7 +93,7 @@ static unsigned int vni_hash_key_make(const void *p)
 /*
  * Comparison function for vni hash
  */
-static bool vni_hash_cmp(const void *p1, const void *p2)
+bool vni_hash_cmp(const void *p1, const void *p2)
 {
 	const struct bgpevpn *vpn1 = p1;
 	const struct bgpevpn *vpn2 = p2;
@@ -114,7 +112,7 @@ int vni_list_cmp(void *p1, void *p2)
 /*
  * Make vrf import route target hash key.
  */
-static unsigned int vrf_import_rt_hash_key_make(const void *p)
+unsigned int  vrf_import_rt_hash_key_make(const void *p)
 {
 	const struct vrf_irt_node *irt = p;
 	const char *pnt = irt->rt.val;
@@ -125,7 +123,7 @@ static unsigned int vrf_import_rt_hash_key_make(const void *p)
 /*
  * Comparison function for vrf import rt hash
  */
-static bool vrf_import_rt_hash_cmp(const void *p1, const void *p2)
+bool vrf_import_rt_hash_cmp(const void *p1, const void *p2)
 {
 	const struct vrf_irt_node *irt1 = p1;
 	const struct vrf_irt_node *irt2 = p2;
@@ -136,7 +134,7 @@ static bool vrf_import_rt_hash_cmp(const void *p1, const void *p2)
 /*
  * Create a new vrf import_rt in evpn instance
  */
-static struct vrf_irt_node *vrf_import_rt_new(struct ecommunity_val *rt)
+struct vrf_irt_node *vrf_import_rt_new(struct ecommunity_val *rt)
 {
 	struct bgp *bgp_evpn = NULL;
 	struct vrf_irt_node *irt;
@@ -163,7 +161,7 @@ static struct vrf_irt_node *vrf_import_rt_new(struct ecommunity_val *rt)
 /*
  * Free the vrf import rt node
  */
-static void vrf_import_rt_free(struct vrf_irt_node *irt)
+void vrf_import_rt_free(struct vrf_irt_node *irt)
 {
 	struct bgp *bgp_evpn = NULL;

@@ -179,7 +177,7 @@ static void vrf_import_rt_free(struct vrf_irt_node *irt)
 	XFREE(MTYPE_BGP_EVPN_VRF_IMPORT_RT, irt);
 }

-static void hash_vrf_import_rt_free(struct vrf_irt_node *irt)
+void hash_vrf_import_rt_free(struct vrf_irt_node *irt)
 {
 	XFREE(MTYPE_BGP_EVPN_VRF_IMPORT_RT, irt);
 }
@@ -188,7 +186,7 @@ static void hash_vrf_import_rt_free(struct vrf_irt_node *irt)
  * Function to lookup Import RT node - used to map a RT to set of
  * VNIs importing routes with that RT.
  */
-static struct vrf_irt_node *lookup_vrf_import_rt(struct ecommunity_val *rt)
+struct vrf_irt_node *lookup_vrf_import_rt(struct ecommunity_val *rt)
 {
 	struct bgp *bgp_evpn = NULL;
 	struct vrf_irt_node *irt;
@@ -211,7 +209,7 @@ static struct vrf_irt_node *lookup_vrf_import_rt(struct ecommunity_val *rt)
 /*
  * Is specified VRF present on the RT's list of "importing" VRFs?
  */
-static int is_vrf_present_in_irt_vrfs(struct list *vrfs, struct bgp *bgp_vrf)
+int is_vrf_present_in_irt_vrfs(struct list *vrfs, struct bgp *bgp_vrf)
 {
 	struct listnode *node = NULL, *nnode = NULL;
 	struct bgp *tmp_bgp_vrf = NULL;
@@ -226,7 +224,7 @@ static int is_vrf_present_in_irt_vrfs(struct list *vrfs, struct bgp *bgp_vrf)
 /*
  * Make import route target hash key.
  */
-static unsigned int import_rt_hash_key_make(const void *p)
+unsigned int  import_rt_hash_key_make(const void *p)
 {
 	const struct irt_node *irt = p;
 	const char *pnt = irt->rt.val;
@@ -237,7 +235,7 @@ static unsigned int import_rt_hash_key_make(const void *p)
 /*
  * Comparison function for import rt hash
  */
-static bool import_rt_hash_cmp(const void *p1, const void *p2)
+bool import_rt_hash_cmp(const void *p1, const void *p2)
 {
 	const struct irt_node *irt1 = p1;
 	const struct irt_node *irt2 = p2;
@@ -248,7 +246,7 @@ static bool import_rt_hash_cmp(const void *p1, const void *p2)
 /*
  * Create a new import_rt
  */
-static struct irt_node *import_rt_new(struct bgp *bgp,
+struct irt_node *import_rt_new(struct bgp *bgp,
 				      struct ecommunity_val *rt)
 {
 	struct irt_node *irt;
@@ -267,14 +265,14 @@ static struct irt_node *import_rt_new(struct bgp *bgp,
 /*
  * Free the import rt node
  */
-static void import_rt_free(struct bgp *bgp, struct irt_node *irt)
+void import_rt_free(struct bgp *bgp, struct irt_node *irt)
 {
 	hash_release(bgp->import_rt_hash, irt);
 	list_delete(&irt->vnis);
 	XFREE(MTYPE_BGP_EVPN_IMPORT_RT, irt);
 }

-static void hash_import_rt_free(struct irt_node *irt)
+void hash_import_rt_free(struct irt_node *irt)
 {
 	XFREE(MTYPE_BGP_EVPN_IMPORT_RT, irt);
 }
@@ -283,7 +281,7 @@ static void hash_import_rt_free(struct irt_node *irt)
  * Function to lookup Import RT node - used to map a RT to set of
  * VNIs importing routes with that RT.
  */
-static struct irt_node *lookup_import_rt(struct bgp *bgp,
+struct irt_node *lookup_import_rt(struct bgp *bgp,
 					 struct ecommunity_val *rt)
 {
 	struct irt_node *irt;
@@ -298,7 +296,7 @@ static struct irt_node *lookup_import_rt(struct bgp *bgp,
 /*
  * Is specified VNI present on the RT's list of "importing" VNIs?
  */
-static int is_vni_present_in_irt_vnis(struct list *vnis, struct bgpevpn *vpn)
+int is_vni_present_in_irt_vnis(struct list *vnis, struct bgpevpn *vpn)
 {
 	struct listnode *node, *nnode;
 	struct bgpevpn *tmp_vpn;
@@ -384,7 +382,7 @@ int bgp_evpn_route_target_cmp(struct ecommunity *ecom1,
 /*
  * Compare L3 Route Targets.
  */
-static int evpn_vrf_route_target_cmp(struct vrf_route_target *rt1,
+int evpn_vrf_route_target_cmp(struct vrf_route_target *rt1,
 				     struct vrf_route_target *rt2)
 {
 	return bgp_evpn_route_target_cmp(rt1->ecom, rt2->ecom);
@@ -399,7 +397,7 @@ void bgp_evpn_xxport_delete_ecomm(void *val)
 /*
  * Delete l3 Route Target.
  */
-static void evpn_vrf_rt_del(void *val)
+void evpn_vrf_rt_del(void *val)
 {
 	struct vrf_route_target *l3rt = val;

@@ -411,7 +409,7 @@ static void evpn_vrf_rt_del(void *val)
 /*
  * Allocate a new l3 Route Target.
  */
-static struct vrf_route_target *evpn_vrf_rt_new(struct ecommunity *ecom)
+struct vrf_route_target *evpn_vrf_rt_new(struct ecommunity *ecom)
 {
 	struct vrf_route_target *l3rt;

@@ -446,7 +444,7 @@ static inline void mask_ecom_global_admin(struct ecommunity_val *dst,
  * Converts the RT to Ecommunity Value and adjusts masking based
  * on flags set for RT.
  */
-static void vrf_rt2ecom_val(struct ecommunity_val *to_eval,
+void vrf_rt2ecom_val(struct ecommunity_val *to_eval,
 			    const struct vrf_route_target *l3rt, int iter)
 {
 	const struct ecommunity_val *eval;
@@ -470,7 +468,7 @@ static void vrf_rt2ecom_val(struct ecommunity_val *to_eval,
  * Map one RT to specified VRF.
  * bgp_vrf = BGP vrf instance
  */
-static void map_vrf_to_rt(struct bgp *bgp_vrf, struct vrf_route_target *l3rt)
+void map_vrf_to_rt(struct bgp *bgp_vrf, struct vrf_route_target *l3rt)
 {
 	uint32_t i = 0;

@@ -499,7 +497,7 @@ static void map_vrf_to_rt(struct bgp *bgp_vrf, struct vrf_route_target *l3rt)
  * VRFs for this RT, then the RT hash is deleted.
  * bgp_vrf: BGP VRF specific instance
  */
-static void unmap_vrf_from_rt(struct bgp *bgp_vrf,
+void unmap_vrf_from_rt(struct bgp *bgp_vrf,
 			      struct vrf_route_target *l3rt)
 {
 	uint32_t i;
@@ -527,7 +525,7 @@ static void unmap_vrf_from_rt(struct bgp *bgp_vrf,
 /*
  * Map one RT to specified VNI.
  */
-static void map_vni_to_rt(struct bgp *bgp, struct bgpevpn *vpn,
+void map_vni_to_rt(struct bgp *bgp, struct bgpevpn *vpn,
 			  struct ecommunity_val *eval)
 {
 	struct irt_node *irt;
@@ -558,7 +556,7 @@ static void map_vni_to_rt(struct bgp *bgp, struct bgpevpn *vpn,
  * Unmap specified VNI from specified RT. If there are no other
  * VNIs for this RT, then the RT hash is deleted.
  */
-static void unmap_vni_from_rt(struct bgp *bgp, struct bgpevpn *vpn,
+void unmap_vni_from_rt(struct bgp *bgp, struct bgpevpn *vpn,
 			      struct irt_node *irt)
 {
 	/* Delete VNI from hash list for this RT. */
@@ -568,7 +566,7 @@ static void unmap_vni_from_rt(struct bgp *bgp, struct bgpevpn *vpn,
 	}
 }

-static void bgp_evpn_get_rmac_nexthop(struct bgpevpn *vpn,
+void bgp_evpn_get_rmac_nexthop(struct bgpevpn *vpn,
 				      const struct prefix_evpn *p,
 				      struct attr *attr, uint8_t flags)
 {
@@ -609,7 +607,7 @@ static void bgp_evpn_get_rmac_nexthop(struct bgpevpn *vpn,
  * VNIs but the same across routers (in the same AS) for a particular
  * VNI.
  */
-static void form_auto_rt(struct bgp *bgp, vni_t vni, struct list *rtl,
+void form_auto_rt(struct bgp *bgp, vni_t vni, struct list *rtl,
 			 bool is_l3)
 {
 	struct ecommunity_val eval;
@@ -657,7 +655,7 @@ static void form_auto_rt(struct bgp *bgp, vni_t vni, struct list *rtl,
  * Derive RD and RT for a VNI automatically. Invoked at the time of
  * creation of a VNI.
  */
-static void derive_rd_rt_for_vni(struct bgp *bgp, struct bgpevpn *vpn)
+void derive_rd_rt_for_vni(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	bgp_evpn_derive_auto_rd(bgp, vpn);
 	bgp_evpn_derive_auto_rt_import(bgp, vpn);
@@ -667,7 +665,7 @@ static void derive_rd_rt_for_vni(struct bgp *bgp, struct bgpevpn *vpn)
 /*
  * Convert nexthop (remote VTEP IP) into an IPv6 address.
  */
-static void evpn_convert_nexthop_to_ipv6(struct attr *attr)
+void evpn_convert_nexthop_to_ipv6(struct attr *attr)
 {
 	if (BGP_ATTR_NEXTHOP_AFI_IP6(attr))
 		return;
@@ -892,7 +890,7 @@ struct bgp_dest *bgp_evpn_vni_node_lookup(const struct bgpevpn *vpn,
 /*
  * Add (update) or delete MACIP from zebra.
  */
-static int bgp_zebra_send_remote_macip(struct bgp *bgp, struct bgpevpn *vpn,
+enum zclient_send_status bgp_zebra_send_remote_macip(struct bgp *bgp, struct bgpevpn *vpn,
 				       const struct prefix_evpn *p,
 				       const struct ethaddr *mac,
 				       struct in_addr remote_vtep_ip, int add,
@@ -903,9 +901,12 @@ static int bgp_zebra_send_remote_macip(struct bgp *bgp, struct bgpevpn *vpn,
 	static struct in_addr zero_remote_vtep_ip;
 	bool esi_valid;

-	/* Check socket. */
-	if (!zclient || zclient->sock < 0)
-		return 0;
+	if (!zclient || zclient->sock < 0) {
+		if (BGP_DEBUG(zebra, ZEBRA))
+			zlog_debug("%s: No zclient or zclient->sock exists",
+				   __func__);
+		return ZCLIENT_SEND_SUCCESS;
+	}

 	/* Don't try to register if Zebra doesn't know of this instance. */
 	if (!IS_BGP_INST_KNOWN_TO_ZEBRA(bgp)) {
@@ -913,7 +914,7 @@ static int bgp_zebra_send_remote_macip(struct bgp *bgp, struct bgpevpn *vpn,
 			zlog_debug(
 				"%s: No zebra instance to talk to, not installing remote macip",
 				__func__);
-		return 0;
+		return ZCLIENT_SEND_SUCCESS;
 	}

 	if (!esi)
@@ -988,15 +989,18 @@ static int bgp_zebra_send_remote_macip(struct bgp *bgp, struct bgpevpn *vpn,
 /*
  * Add (update) or delete remote VTEP from zebra.
  */
-static int bgp_zebra_send_remote_vtep(struct bgp *bgp, struct bgpevpn *vpn,
+enum zclient_send_status bgp_zebra_send_remote_vtep(struct bgp *bgp, struct bgpevpn *vpn,
 				      const struct prefix_evpn *p,
 				      int flood_control, int add)
 {
 	struct stream *s;

-	/* Check socket. */
-	if (!zclient || zclient->sock < 0)
-		return 0;
+	if (!zclient || zclient->sock < 0) {
+		if (BGP_DEBUG(zebra, ZEBRA))
+			zlog_debug("%s: No zclient or zclient->sock exists",
+				   __func__);
+		return ZCLIENT_SEND_SUCCESS;
+	}

 	/* Don't try to register if Zebra doesn't know of this instance. */
 	if (!IS_BGP_INST_KNOWN_TO_ZEBRA(bgp)) {
@@ -1004,7 +1008,7 @@ static int bgp_zebra_send_remote_vtep(struct bgp *bgp, struct bgpevpn *vpn,
 			zlog_debug(
 				"%s: No zebra instance to talk to, not installing remote vtep",
 				__func__);
-		return 0;
+		return ZCLIENT_SEND_SUCCESS;
 	}

 	s = zclient->obuf;
@@ -1021,7 +1025,7 @@ static int bgp_zebra_send_remote_vtep(struct bgp *bgp, struct bgpevpn *vpn,
 			EC_BGP_VTEP_INVALID,
 			"Bad remote IP when trying to %s remote VTEP for VNI %u",
 			add ? "ADD" : "DEL", (vpn ? vpn->vni : 0));
-		return -1;
+		return ZCLIENT_SEND_FAILURE;
 	}
 	stream_putl(s, flood_control);

@@ -1043,7 +1047,7 @@ static int bgp_zebra_send_remote_vtep(struct bgp *bgp, struct bgpevpn *vpn,
 /*
  * Build extended communities for EVPN prefix route.
  */
-static void build_evpn_type5_route_extcomm(struct bgp *bgp_vrf,
+void build_evpn_type5_route_extcomm(struct bgp *bgp_vrf,
 					   struct attr *attr)
 {
 	struct ecommunity ecom_encap;
@@ -1100,7 +1104,7 @@ static void build_evpn_type5_route_extcomm(struct bgp *bgp_vrf,
  * added, if present, based on passed settings - only for non-link-local
  * type-2 routes.
  */
-static void build_evpn_route_extcomm(struct bgpevpn *vpn, struct attr *attr,
+void build_evpn_route_extcomm(struct bgpevpn *vpn, struct attr *attr,
 				     int add_l3_ecomm,
 				     struct ecommunity *macvrf_soo)
 {
@@ -1209,7 +1213,7 @@ static void build_evpn_route_extcomm(struct bgpevpn *vpn, struct attr *attr,
 /*
  * Add MAC mobility extended community to attribute.
  */
-static void add_mac_mobility_to_attr(uint32_t seq_num, struct attr *attr)
+void add_mac_mobility_to_attr(uint32_t seq_num, struct attr *attr)
 {
 	struct ecommunity ecom_tmp;
 	struct ecommunity_val eval;
@@ -1263,14 +1267,14 @@ static void add_mac_mobility_to_attr(uint32_t seq_num, struct attr *attr)
 }

 /* Install EVPN route into zebra. */
-static int evpn_zebra_install(struct bgp *bgp, struct bgpevpn *vpn,
+enum zclient_send_status  evpn_zebra_install(struct bgp *bgp, struct bgpevpn *vpn,
 			      const struct prefix_evpn *p,
 			      struct bgp_path_info *pi)
 {
-	int ret;
 	uint8_t flags;
 	int flood_control = VXLAN_FLOOD_DISABLED;
 	uint32_t seq;
+	enum zclient_send_status ret = ZCLIENT_SEND_SUCCESS;

 	if (p->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE) {
 		flags = 0;
@@ -1355,11 +1359,11 @@ static int evpn_zebra_install(struct bgp *bgp, struct bgpevpn *vpn,
 }

 /* Uninstall EVPN route from zebra. */
-static int evpn_zebra_uninstall(struct bgp *bgp, struct bgpevpn *vpn,
+enum zclient_send_status evpn_zebra_uninstall(struct bgp *bgp, struct bgpevpn *vpn,
 				const struct prefix_evpn *p,
 				struct bgp_path_info *pi, bool is_sync)
 {
-	int ret;
+	enum zclient_send_status ret = ZCLIENT_SEND_SUCCESS;

 	if (p->prefix.route_type == BGP_EVPN_MAC_IP_ROUTE)
 		ret = bgp_zebra_send_remote_macip(
@@ -1384,7 +1388,7 @@ static int evpn_zebra_uninstall(struct bgp *bgp, struct bgpevpn *vpn,
  * by a "remote" best route. The prior route has to be deleted and withdrawn
  * from peers.
  */
-static void evpn_delete_old_local_route(struct bgp *bgp, struct bgpevpn *vpn,
+void evpn_delete_old_local_route(struct bgp *bgp, struct bgpevpn *vpn,
 					struct bgp_dest *dest,
 					struct bgp_path_info *old_local,
 					struct bgp_path_info *new_select)
@@ -1465,12 +1469,17 @@ int evpn_route_select_install(struct bgp *bgp, struct bgpevpn *vpn,
 	    && !CHECK_FLAG(dest->flags, BGP_NODE_USER_CLEAR)
 	    && !CHECK_FLAG(old_select->flags, BGP_PATH_ATTR_CHANGED)
 	    && !bgp_addpath_is_addpath_used(&bgp->tx_addpath, afi, safi)) {
-		if (bgp_zebra_has_route_changed(old_select))
-			ret = evpn_zebra_install(
-				bgp, vpn,
-				(const struct prefix_evpn *)bgp_dest_get_prefix(
-					dest),
-				old_select);
+		if (bgp_zebra_has_route_changed(old_select)) {
+			if (CHECK_FLAG(bgp->flags, BGP_FLAG_DELETE_IN_PROGRESS))
+				evpn_zebra_install(
+					bgp, vpn,
+					(const struct prefix_evpn *)
+						bgp_dest_get_prefix(dest),
+					old_select);
+			else
+				bgp_zebra_route_install(dest, old_select, bgp,
+							true, vpn, false);
+		}
 		UNSET_FLAG(old_select->flags, BGP_PATH_MULTIPATH_CHG);
 		UNSET_FLAG(old_select->flags, BGP_PATH_LINK_BW_CHG);
 		bgp_zebra_clear_route_change_flags(dest);
@@ -1502,10 +1511,14 @@ int evpn_route_select_install(struct bgp *bgp, struct bgpevpn *vpn,
 	if (new_select && new_select->type == ZEBRA_ROUTE_BGP
 	    && (new_select->sub_type == BGP_ROUTE_IMPORTED ||
 			bgp_evpn_attr_is_sync(new_select->attr))) {
-		ret = evpn_zebra_install(
-			bgp, vpn,
-			(struct prefix_evpn *)bgp_dest_get_prefix(dest),
-			new_select);
+		if (CHECK_FLAG(bgp->flags, BGP_FLAG_DELETE_IN_PROGRESS))
+			evpn_zebra_install(bgp, vpn,
+					   (const struct prefix_evpn *)
+						   bgp_dest_get_prefix(dest),
+					   new_select);
+		else
+			bgp_zebra_route_install(dest, new_select, bgp, true,
+						vpn, false);

 		/* If an old best existed and it was a "local" route, the only
 		 * reason
@@ -1522,13 +1535,20 @@ int evpn_route_select_install(struct bgp *bgp, struct bgpevpn *vpn,
 			evpn_delete_old_local_route(bgp, vpn, dest,
 					old_select, new_select);
 	} else {
-		if (old_select && old_select->type == ZEBRA_ROUTE_BGP
-		    && old_select->sub_type == BGP_ROUTE_IMPORTED)
-			ret = evpn_zebra_uninstall(
-				bgp, vpn,
-				(const struct prefix_evpn *)bgp_dest_get_prefix(
-					dest),
-				old_select, false);
+		if (old_select && old_select->type == ZEBRA_ROUTE_BGP &&
+		    old_select->sub_type == BGP_ROUTE_IMPORTED) {
+			if (CHECK_FLAG(bgp->flags,
+				       BGP_FLAG_DELETE_IN_PROGRESS) ||
+			    CHECK_FLAG(bgp->flags, BGP_FLAG_VNI_DOWN))
+				evpn_zebra_uninstall(
+					bgp, vpn,
+					(const struct prefix_evpn *)
+						bgp_dest_get_prefix(dest),
+					old_select, false);
+			else
+				bgp_zebra_route_install(dest, old_select, bgp,
+							false, vpn, false);
+		}
 	}

 	/* Clear any route change flags. */
@@ -1541,7 +1561,7 @@ int evpn_route_select_install(struct bgp *bgp, struct bgpevpn *vpn,
 	return ret;
 }

-static struct bgp_path_info *bgp_evpn_route_get_local_path(
+struct bgp_path_info *bgp_evpn_route_get_local_path(
 		struct bgp *bgp, struct bgp_dest *dest)
 {
 	struct bgp_path_info *tmp_pi;
@@ -1558,7 +1578,7 @@ static struct bgp_path_info *bgp_evpn_route_get_local_path(
 	return local_pi;
 }

-static int update_evpn_type5_route_entry(struct bgp *bgp_evpn,
+int update_evpn_type5_route_entry(struct bgp *bgp_evpn,
 					 struct bgp *bgp_vrf, afi_t afi,
 					 safi_t safi, struct bgp_dest *dest,
 					 struct attr *attr, int *route_changed)
@@ -1627,7 +1647,7 @@ static int update_evpn_type5_route_entry(struct bgp *bgp_evpn,
 }

 /* update evpn type-5 route entry */
-static int update_evpn_type5_route(struct bgp *bgp_vrf, struct prefix_evpn *evp,
+int update_evpn_type5_route(struct bgp *bgp_vrf, struct prefix_evpn *evp,
 				   struct attr *src_attr, afi_t src_afi,
 				   safi_t src_safi)
 {
@@ -1732,7 +1752,7 @@ static int update_evpn_type5_route(struct bgp *bgp_vrf, struct prefix_evpn *evp,
 	return 0;
 }

-static void bgp_evpn_get_sync_info(struct bgp *bgp, esi_t *esi,
+void bgp_evpn_get_sync_info(struct bgp *bgp, esi_t *esi,
 				   struct bgp_dest *dest, uint32_t loc_seq,
 				   uint32_t *max_sync_seq, bool *active_on_peer,
 				   bool *peer_router, bool *proxy_from_peer,
@@ -1809,7 +1829,7 @@ static void bgp_evpn_get_sync_info(struct bgp *bgp, esi_t *esi,
  * Note: The local path can only exist as a best path in the
  * VPN route table. It will take precedence over all sync paths.
  */
-static void update_evpn_route_entry_sync_info(struct bgp *bgp,
+void update_evpn_route_entry_sync_info(struct bgp *bgp,
 					      struct bgp_dest *dest,
 					      struct attr *attr,
 					      uint32_t loc_seq, bool setup_sync,
@@ -1879,7 +1899,7 @@ static void update_evpn_route_entry_sync_info(struct bgp *bgp,
  * Create or update EVPN route entry. This could be in the VNI route tables
  * or the global route table.
  */
-static int update_evpn_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
+int update_evpn_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
 				   afi_t afi, safi_t safi,
 				   struct bgp_dest *dest, struct attr *attr,
 				   const struct ethaddr *mac,
@@ -2044,7 +2064,7 @@ static int update_evpn_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
 	return route_change;
 }

-static void evpn_zebra_reinstall_best_route(struct bgp *bgp,
+void evpn_zebra_reinstall_best_route(struct bgp *bgp,
 					    struct bgpevpn *vpn,
 					    struct bgp_dest *dest)
 {
@@ -2062,9 +2082,19 @@ static void evpn_zebra_reinstall_best_route(struct bgp *bgp,
 	if (curr_select && curr_select->type == ZEBRA_ROUTE_BGP
 			&& (curr_select->sub_type == BGP_ROUTE_IMPORTED ||
 				bgp_evpn_attr_is_sync(curr_select->attr)))
-		evpn_zebra_install(bgp, vpn,
-		   (const struct prefix_evpn *)bgp_dest_get_prefix(dest),
-		   curr_select);
+		if (curr_select && curr_select->type == ZEBRA_ROUTE_BGP &&
+		    (curr_select->sub_type == BGP_ROUTE_IMPORTED ||
+		     bgp_evpn_attr_is_sync(curr_select->attr))) {
+			if (CHECK_FLAG(bgp->flags, BGP_FLAG_DELETE_IN_PROGRESS))
+				evpn_zebra_install(
+					bgp, vpn,
+					(const struct prefix_evpn *)
+						bgp_dest_get_prefix(dest),
+					curr_select);
+			else
+				bgp_zebra_route_install(dest, curr_select, bgp,
+							true, vpn, false);
+		}
 }

 /*
@@ -2081,7 +2111,7 @@ static void evpn_zebra_reinstall_best_route(struct bgp *bgp,
  * additional handling to prevent bgp from injecting and holding on to a
  * non-best local path.
  */
-static struct bgp_dest *
+struct bgp_dest *
 evpn_cleanup_local_non_best_route(struct bgp *bgp, struct bgpevpn *vpn,
 				  struct bgp_dest *dest,
 				  struct bgp_path_info *local_pi)
@@ -2099,7 +2129,7 @@ evpn_cleanup_local_non_best_route(struct bgp *bgp, struct bgpevpn *vpn,
 	return bgp_path_info_reap(dest, local_pi);
 }

-static inline bool bgp_evpn_route_add_l3_ecomm_ok(struct bgpevpn *vpn,
+inline bool bgp_evpn_route_add_l3_ecomm_ok(struct bgpevpn *vpn,
 						  const struct prefix_evpn *p,
 						  esi_t *esi)
 {
@@ -2116,7 +2146,7 @@ static inline bool bgp_evpn_route_add_l3_ecomm_ok(struct bgpevpn *vpn,
  * Create or update EVPN route (of type based on prefix) for specified VNI
  * and schedule for processing.
  */
-static int update_evpn_route(struct bgp *bgp, struct bgpevpn *vpn,
+int update_evpn_route(struct bgp *bgp, struct bgpevpn *vpn,
 			     struct prefix_evpn *p, uint8_t flags,
 			     uint32_t seq, esi_t *esi)
 {
@@ -2245,8 +2275,16 @@ static int update_evpn_route(struct bgp *bgp, struct bgpevpn *vpn,
 			 * has been removed.
 			 */
 			new_is_sync = bgp_evpn_attr_is_sync(pi->attr);
-			if (!new_is_sync && old_is_sync)
-				evpn_zebra_uninstall(bgp, vpn, p, pi, true);
+			if (!new_is_sync && old_is_sync) {
+				if (CHECK_FLAG(bgp->flags,
+					       BGP_FLAG_DELETE_IN_PROGRESS))
+					evpn_zebra_uninstall(bgp, vpn, p, pi,
+							     true);
+				else
+					bgp_zebra_route_install(dest, pi, bgp,
+								false, vpn,
+								true);
+			}
 		}
 	}
 	bgp_path_info_unlock(pi);
@@ -2308,7 +2346,7 @@ void delete_evpn_route_entry(struct bgp *bgp, afi_t afi, safi_t safi,
 }

 /* Delete EVPN type5 route */
-static int delete_evpn_type5_route(struct bgp *bgp_vrf, struct prefix_evpn *evp)
+int delete_evpn_type5_route(struct bgp *bgp_vrf, struct prefix_evpn *evp)
 {
 	afi_t afi = AFI_L2VPN;
 	safi_t safi = SAFI_EVPN;
@@ -2339,7 +2377,7 @@ static int delete_evpn_type5_route(struct bgp *bgp_vrf, struct prefix_evpn *evp)
  * Delete EVPN route (of type based on prefix) for specified VNI and
  * schedule for processing.
  */
-static int delete_evpn_route(struct bgp *bgp, struct bgpevpn *vpn,
+int delete_evpn_route(struct bgp *bgp, struct bgpevpn *vpn,
 			     struct prefix_evpn *p)
 {
 	struct bgp_dest *dest, *global_dest;
@@ -2408,6 +2446,7 @@ void bgp_evpn_update_type2_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
 	int route_change;
 	bool old_is_sync = false;
 	struct ecommunity *macvrf_soo = NULL;
+	struct prefix_evpn p;

 	if (CHECK_FLAG(local_pi->flags, BGP_PATH_REMOVED))
 		return;
@@ -2512,8 +2551,16 @@ void bgp_evpn_update_type2_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
 			 * has been removed.
 			 */
 			new_is_sync = bgp_evpn_attr_is_sync(pi->attr);
-			if (!new_is_sync && old_is_sync)
-				evpn_zebra_uninstall(bgp, vpn, &evp, pi, true);
+			if (!new_is_sync && old_is_sync) {
+				if (CHECK_FLAG(bgp->flags,
+					       BGP_FLAG_DELETE_IN_PROGRESS))
+					evpn_zebra_uninstall(bgp, vpn, &p, pi,
+							     true);
+				else
+					bgp_zebra_route_install(dest, pi, bgp,
+								false, vpn,
+								true);
+			}
 		}
 	}

@@ -2541,7 +2588,7 @@ void bgp_evpn_update_type2_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
 	aspath_unintern(&attr.aspath);
 }

-static void update_type2_route(struct bgp *bgp, struct bgpevpn *vpn,
+void update_type2_route(struct bgp *bgp, struct bgpevpn *vpn,
 			       struct bgp_dest *dest)
 {
 	struct bgp_path_info *tmp_pi;
@@ -2571,7 +2618,7 @@ static void update_type2_route(struct bgp *bgp, struct bgpevpn *vpn,
  * Update all type-2 (MACIP) local routes for this VNI - these should also
  * be scheduled for advertise to peers.
  */
-static void update_all_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
+void update_all_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	struct bgp_dest *dest;

@@ -2592,7 +2639,7 @@ static void update_all_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
  * Delete all type-2 (MACIP) local routes for this VNI - only from the
  * global routing table. These are also scheduled for withdraw from peers.
  */
-static void delete_global_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
+void delete_global_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	afi_t afi;
 	safi_t safi;
@@ -2626,7 +2673,7 @@ static void delete_global_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
 	}
 }

-static struct bgp_dest *delete_vni_type2_route(struct bgp *bgp,
+struct bgp_dest *delete_vni_type2_route(struct bgp *bgp,
 					       struct bgp_dest *dest)
 {
 	struct bgp_path_info *pi;
@@ -2648,7 +2695,7 @@ static struct bgp_dest *delete_vni_type2_route(struct bgp *bgp,
 	return dest;
 }

-static void delete_vni_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
+void delete_vni_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	struct bgp_dest *dest;

@@ -2672,7 +2719,7 @@ static void delete_vni_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
  * Delete all type-2 (MACIP) local routes for this VNI - from the global
  * table as well as the per-VNI route table.
  */
-static void delete_all_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
+void delete_all_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	/* First, walk the global route table for this VNI's type-2 local
 	 * routes.
@@ -2685,7 +2732,7 @@ static void delete_all_type2_routes(struct bgp *bgp, struct bgpevpn *vpn)
 /*
  * Delete all routes in the per-VNI route table.
  */
-static void delete_all_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
+void delete_all_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	struct bgp_dest *dest;
 	struct bgp_path_info *pi, *nextpi;
@@ -2716,7 +2763,7 @@ static void delete_all_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
 }

 /* BUM traffic flood mode per-l2-vni */
-static int bgp_evpn_vni_flood_mode_get(struct bgp *bgp,
+int bgp_evpn_vni_flood_mode_get(struct bgp *bgp,
 					struct bgpevpn *vpn)
 {
 	/* if flooding has been globally disabled per-vni mode is
@@ -2766,7 +2813,7 @@ int update_routes_for_vni(struct bgp *bgp, struct bgpevpn *vpn)
 /* Update Type-2/3 Routes for L2VNI.
  * Called by hash_iterate()
  */
-static void update_routes_for_vni_hash(struct hash_bucket *bucket,
+void update_routes_for_vni_hash(struct hash_bucket *bucket,
 				       struct bgp *bgp)
 {
 	struct bgpevpn *vpn;
@@ -2784,7 +2831,7 @@ static void update_routes_for_vni_hash(struct hash_bucket *bucket,
  * the per-VNI table. Invoked upon the VNI being deleted or EVPN
  * (advertise-all-vni) being disabled.
  */
-static int delete_routes_for_vni(struct bgp *bgp, struct bgpevpn *vpn)
+int delete_routes_for_vni(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	int ret;
 	struct prefix_evpn p;
@@ -2795,7 +2842,22 @@ static int delete_routes_for_vni(struct bgp *bgp, struct bgpevpn *vpn)
 	delete_all_type2_routes(bgp, vpn);

 	build_evpn_type3_prefix(&p, vpn->originator_ip);
+
+	/*
+	 * To handle the following scenario:
+	 *  - Say, the new zebra announce fifo list has few vni Evpn prefixes
+	 * yet to be sent to zebra.
+	 *  - At this point if we have triggers like "no advertise-all-vni" or
+	 *    "networking restart", where a vni is going down.
+	 *
+	 * Perform the below
+	 *    1) send withdraw routes to zebra immediately in case it is
+	 * installed. 2) before we blow up the vni table, we need to walk the
+	 * list and pop all the dest whose za_vpn points to this vni.
+	 */
+	SET_FLAG(bgp->flags, BGP_FLAG_VNI_DOWN);
 	ret = delete_evpn_route(bgp, vpn, &p);
+	UNSET_FLAG(bgp->flags, BGP_FLAG_VNI_DOWN);
 	if (ret)
 		return ret;

@@ -2809,7 +2871,7 @@ static int delete_routes_for_vni(struct bgp *bgp, struct bgpevpn *vpn)
  * remove the type-3 route if any. A new type-3 route will be generated
  * post tunnel_ip update if the new flood mode is head-end-replication.
  */
-static int bgp_evpn_mcast_grp_change(struct bgp *bgp, struct bgpevpn *vpn,
+int bgp_evpn_mcast_grp_change(struct bgp *bgp, struct bgpevpn *vpn,
 		struct in_addr mcast_grp)
 {
 	struct prefix_evpn p;
@@ -2833,7 +2895,7 @@ static int bgp_evpn_mcast_grp_change(struct bgp *bgp, struct bgpevpn *vpn,
  * Note: Route re-advertisement happens elsewhere after other processing
  * other changes.
  */
-static void handle_tunnel_ip_change(struct bgp *bgp_vrf, struct bgp *bgp_evpn,
+void handle_tunnel_ip_change(struct bgp *bgp_vrf, struct bgp *bgp_evpn,
 				    struct bgpevpn *vpn,
 				    struct in_addr originator_ip)
 {
@@ -2882,7 +2944,7 @@ static void handle_tunnel_ip_change(struct bgp *bgp_vrf, struct bgp *bgp_evpn,
 	return;
 }

-static struct bgp_path_info *
+struct bgp_path_info *
 bgp_create_evpn_bgp_path_info(struct bgp_path_info *parent_pi,
 			      struct bgp_dest *dest, struct attr *attr)
 {
@@ -2918,7 +2980,7 @@ bgp_create_evpn_bgp_path_info(struct bgp_path_info *parent_pi,
 /*
  * Install route entry into the VRF routing table and invoke route selection.
  */
-static int install_evpn_route_entry_in_vrf(struct bgp *bgp_vrf,
+int install_evpn_route_entry_in_vrf(struct bgp *bgp_vrf,
 					   const struct prefix_evpn *evp,
 					   struct bgp_path_info *parent_pi)
 {
@@ -3102,7 +3164,7 @@ static int install_evpn_route_entry_in_vrf(struct bgp *bgp_vrf,
 /*
  * Common handling for vni route tables install/selection.
  */
-static int install_evpn_route_entry_in_vni_common(
+int install_evpn_route_entry_in_vni_common(
 	struct bgp *bgp, struct bgpevpn *vpn, const struct prefix_evpn *p,
 	struct bgp_dest *dest, struct bgp_path_info *parent_pi)
 {
@@ -3202,7 +3264,7 @@ static int install_evpn_route_entry_in_vni_common(
 /*
  * Common handling for vni route tables uninstall/selection.
  */
-static int uninstall_evpn_route_entry_in_vni_common(
+int uninstall_evpn_route_entry_in_vni_common(
 	struct bgp *bgp, struct bgpevpn *vpn, const struct prefix_evpn *p,
 	struct bgp_dest *dest, struct bgp_path_info *parent_pi)
 {
@@ -3243,7 +3305,7 @@ static int uninstall_evpn_route_entry_in_vni_common(
 /*
  * Install route entry into VNI IP table and invoke route selection.
  */
-static int install_evpn_route_entry_in_vni_ip(struct bgp *bgp,
+int install_evpn_route_entry_in_vni_ip(struct bgp *bgp,
 					      struct bgpevpn *vpn,
 					      const struct prefix_evpn *p,
 					      struct bgp_path_info *parent_pi)
@@ -3270,7 +3332,7 @@ static int install_evpn_route_entry_in_vni_ip(struct bgp *bgp,
 /*
  * Install route entry into VNI MAC table and invoke route selection.
  */
-static int install_evpn_route_entry_in_vni_mac(struct bgp *bgp,
+int install_evpn_route_entry_in_vni_mac(struct bgp *bgp,
 					       struct bgpevpn *vpn,
 					       const struct prefix_evpn *p,
 					       struct bgp_path_info *parent_pi)
@@ -3296,7 +3358,7 @@ static int install_evpn_route_entry_in_vni_mac(struct bgp *bgp,
 /*
  * Uninstall route entry from VNI IP table and invoke route selection.
  */
-static int uninstall_evpn_route_entry_in_vni_ip(struct bgp *bgp,
+int uninstall_evpn_route_entry_in_vni_ip(struct bgp *bgp,
 						struct bgpevpn *vpn,
 						const struct prefix_evpn *p,
 						struct bgp_path_info *parent_pi)
@@ -3325,7 +3387,7 @@ static int uninstall_evpn_route_entry_in_vni_ip(struct bgp *bgp,
 /*
  * Uninstall route entry from VNI IP table and invoke route selection.
  */
-static int
+int
 uninstall_evpn_route_entry_in_vni_mac(struct bgp *bgp, struct bgpevpn *vpn,
 				      const struct prefix_evpn *p,
 				      struct bgp_path_info *parent_pi)
@@ -3353,7 +3415,7 @@ uninstall_evpn_route_entry_in_vni_mac(struct bgp *bgp, struct bgpevpn *vpn,
  * Uninstall route entry from the VRF routing table and send message
  * to zebra, if appropriate.
  */
-static int uninstall_evpn_route_entry_in_vrf(struct bgp *bgp_vrf,
+int uninstall_evpn_route_entry_in_vrf(struct bgp *bgp_vrf,
 					     const struct prefix_evpn *evp,
 					     struct bgp_path_info *parent_pi)
 {
@@ -3445,7 +3507,7 @@ static int uninstall_evpn_route_entry_in_vrf(struct bgp *bgp_vrf,
 /*
  * Install route entry into the VNI routing tables.
  */
-static int install_evpn_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
+int install_evpn_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
 				    const struct prefix_evpn *p,
 				    struct bgp_path_info *parent_pi)
 {
@@ -3484,7 +3546,7 @@ static int install_evpn_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
 /*
  * Uninstall route entry from the VNI routing tables.
  */
-static int uninstall_evpn_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
+int uninstall_evpn_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
 				      const struct prefix_evpn *p,
 				      struct bgp_path_info *parent_pi)
 {
@@ -3524,7 +3586,7 @@ static int uninstall_evpn_route_entry(struct bgp *bgp, struct bgpevpn *vpn,
  * Given a route entry and a VRF, see if this route entry should be
  * imported into the VRF i.e., RTs match + Site-of-Origin check passes.
  */
-static int is_route_matching_for_vrf(struct bgp *bgp_vrf,
+int is_route_matching_for_vrf(struct bgp *bgp_vrf,
 				     struct bgp_path_info *pi)
 {
 	struct attr *attr = pi->attr;
@@ -3591,7 +3653,7 @@ static int is_route_matching_for_vrf(struct bgp *bgp_vrf,
  * Given a route entry and a VNI, see if this route entry should be
  * imported into the VNI i.e., RTs match.
  */
-static int is_route_matching_for_vni(struct bgp *bgp, struct bgpevpn *vpn,
+int is_route_matching_for_vni(struct bgp *bgp, struct bgpevpn *vpn,
 				     struct bgp_path_info *pi)
 {
 	struct attr *attr = pi->attr;
@@ -3654,7 +3716,7 @@ static int is_route_matching_for_vni(struct bgp *bgp, struct bgpevpn *vpn,
 	return 0;
 }

-static bool bgp_evpn_route_matches_macvrf_soo(struct bgp_path_info *pi,
+bool bgp_evpn_route_matches_macvrf_soo(struct bgp_path_info *pi,
 					      const struct prefix_evpn *evp)
 {
 	struct bgp *bgp_evpn = bgp_get_evpn();
@@ -3693,7 +3755,7 @@ static bool bgp_evpn_route_matches_macvrf_soo(struct bgp_path_info *pi,
  * macthes with bgp instance router mac. It avoid installing
  * route into bgp vrf table and remote rmac in bridge table.
  */
-static int bgp_evpn_route_rmac_self_check(struct bgp *bgp_vrf,
+int bgp_evpn_route_rmac_self_check(struct bgp *bgp_vrf,
 					  const struct prefix_evpn *evp,
 					  struct bgp_path_info *pi)
 {
@@ -3722,7 +3784,7 @@ static int bgp_evpn_route_rmac_self_check(struct bgp *bgp_vrf,
 }

 /* don't import hosts that are locally attached */
-static inline bool
+inline bool
 bgp_evpn_skip_vrf_import_of_local_es(struct bgp *bgp_vrf,
 				     const struct prefix_evpn *evp,
 				     struct bgp_path_info *pi, int install)
@@ -3799,7 +3861,7 @@ int bgp_evpn_route_entry_install_if_vrf_match(struct bgp *bgp_vrf,
  * Install or uninstall mac-ip routes are appropriate for this
  * particular VRF.
  */
-static int install_uninstall_routes_for_vrf(struct bgp *bgp_vrf, int install)
+int install_uninstall_routes_for_vrf(struct bgp *bgp_vrf, int install)
 {
 	afi_t afi;
 	safi_t safi;
@@ -3862,7 +3924,7 @@ static int install_uninstall_routes_for_vrf(struct bgp *bgp_vrf, int install)
  * Install or uninstall routes of specified type that are appropriate for this
  * particular VNI.
  */
-static int install_uninstall_routes_for_vni(struct bgp *bgp,
+int install_uninstall_routes_for_vni(struct bgp *bgp,
 					    struct bgpevpn *vpn,
 					    bgp_evpn_route_type rtype,
 					    int install)
@@ -3948,7 +4010,7 @@ static int install_uninstall_routes_for_vni(struct bgp *bgp,
 /* Install any existing remote routes applicable for this VRF into VRF RIB. This
  * is invoked upon l3vni-add or l3vni import rt change
  */
-static int install_routes_for_vrf(struct bgp *bgp_vrf)
+int install_routes_for_vrf(struct bgp *bgp_vrf)
 {
 	install_uninstall_routes_for_vrf(bgp_vrf, 1);
 	return 0;
@@ -3959,7 +4021,7 @@ static int install_routes_for_vrf(struct bgp *bgp_vrf)
  * routing table. This is invoked when a VNI becomes "live" or its Import
  * RT is changed.
  */
-static int install_routes_for_vni(struct bgp *bgp, struct bgpevpn *vpn)
+int install_routes_for_vni(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	int ret;

@@ -3981,7 +4043,7 @@ static int install_routes_for_vni(struct bgp *bgp, struct bgpevpn *vpn)
 }

 /* uninstall routes from l3vni vrf. */
-static int uninstall_routes_for_vrf(struct bgp *bgp_vrf)
+int uninstall_routes_for_vrf(struct bgp *bgp_vrf)
 {
 	install_uninstall_routes_for_vrf(bgp_vrf, 0);
 	return 0;
@@ -3991,7 +4053,7 @@ static int uninstall_routes_for_vrf(struct bgp *bgp_vrf)
  * Uninstall any existing remote routes for this VNI. One scenario in which
  * this is invoked is upon an import RT change.
  */
-static int uninstall_routes_for_vni(struct bgp *bgp, struct bgpevpn *vpn)
+int uninstall_routes_for_vni(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	int ret;

@@ -4017,7 +4079,7 @@ static int uninstall_routes_for_vni(struct bgp *bgp, struct bgpevpn *vpn)
 /*
  * Install or uninstall route in matching VRFs (list).
  */
-static int install_uninstall_route_in_vrfs(struct bgp *bgp_def, afi_t afi,
+int install_uninstall_route_in_vrfs(struct bgp *bgp_def, afi_t afi,
 					   safi_t safi, struct prefix_evpn *evp,
 					   struct bgp_path_info *pi,
 					   struct list *vrfs, int install)
@@ -4066,7 +4128,7 @@ static int install_uninstall_route_in_vrfs(struct bgp *bgp_def, afi_t afi,
 /*
  * Install or uninstall route in matching VNIs (list).
  */
-static int install_uninstall_route_in_vnis(struct bgp *bgp, afi_t afi,
+int install_uninstall_route_in_vnis(struct bgp *bgp, afi_t afi,
 					   safi_t safi, struct prefix_evpn *evp,
 					   struct bgp_path_info *pi,
 					   struct list *vnis, int install)
@@ -4103,7 +4165,7 @@ static int install_uninstall_route_in_vnis(struct bgp *bgp, afi_t afi,
 /*
  * Install or uninstall route for appropriate VNIs/ESIs.
  */
-static int bgp_evpn_install_uninstall_table(struct bgp *bgp, afi_t afi,
+int bgp_evpn_install_uninstall_table(struct bgp *bgp, afi_t afi,
 					    safi_t safi, const struct prefix *p,
 					    struct bgp_path_info *pi,
 					    int import, bool in_vni_rt,
@@ -4246,7 +4308,7 @@ static int bgp_evpn_install_uninstall_table(struct bgp *bgp, afi_t afi,
 /*
  * Install or uninstall route for appropriate VNIs/ESIs.
  */
-static int install_uninstall_evpn_route(struct bgp *bgp, afi_t afi, safi_t safi,
+int install_uninstall_evpn_route(struct bgp *bgp, afi_t afi, safi_t safi,
 					const struct prefix *p,
 					struct bgp_path_info *pi, int import)
 {
@@ -4270,7 +4332,7 @@ void bgp_evpn_import_type2_route(struct bgp_path_info *pi, int import)
  * delete and withdraw all ipv4 and ipv6 routes in the vrf table as type-5
  * routes
  */
-static void delete_withdraw_vrf_routes(struct bgp *bgp_vrf)
+void delete_withdraw_vrf_routes(struct bgp *bgp_vrf)
 {
 	/* Delete ipv4 default route and withdraw from peers */
 	if (evpn_default_originate_set(bgp_vrf, AFI_IP, SAFI_UNICAST))
@@ -4329,7 +4391,7 @@ void update_advertise_vrf_routes(struct bgp *bgp_vrf)
  * done in the global route table using the routes which already exist in the
  * VRF routing table
  */
-static void update_router_id_vrf(struct bgp *bgp_vrf)
+void update_router_id_vrf(struct bgp *bgp_vrf)
 {
 	/* skip if the RD is configured */
 	if (is_vrf_rd_configured(bgp_vrf))
@@ -4347,7 +4409,7 @@ static void update_router_id_vrf(struct bgp *bgp_vrf)
  * This is invoked upon VRF RD change. The processing is done only from global
  * table.
  */
-static void withdraw_router_id_vrf(struct bgp *bgp_vrf)
+void withdraw_router_id_vrf(struct bgp *bgp_vrf)
 {
 	/* skip if the RD is configured */
 	if (is_vrf_rd_configured(bgp_vrf))
@@ -4357,7 +4419,7 @@ static void withdraw_router_id_vrf(struct bgp *bgp_vrf)
 	delete_withdraw_vrf_routes(bgp_vrf);
 }

-static void update_advertise_vni_route(struct bgp *bgp, struct bgpevpn *vpn,
+void update_advertise_vni_route(struct bgp *bgp, struct bgpevpn *vpn,
 				       struct bgp_dest *dest)
 {
 	struct bgp_dest *global_dest;
@@ -4440,7 +4502,7 @@ static void update_advertise_vni_route(struct bgp *bgp, struct bgpevpn *vpn,
  * change. Note that the processing is done only on the global route table
  * using routes that already exist in the per-VNI table.
  */
-static void update_advertise_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
+void update_advertise_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	struct prefix_evpn p;
 	struct bgp_dest *dest, *global_dest;
@@ -4501,7 +4563,7 @@ static void update_advertise_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
  * Delete (and withdraw) local routes for a VNI - only from the global
  * table. Invoked upon router-id change.
  */
-static int delete_withdraw_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
+int delete_withdraw_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	struct prefix_evpn p;
 	struct bgp_dest *global_dest;
@@ -4541,7 +4603,7 @@ static int delete_withdraw_vni_routes(struct bgp *bgp, struct bgpevpn *vpn)
  * router-id. The routes in the per-VNI table are used to create routes in
  * the global table and schedule them.
  */
-static void update_router_id_vni(struct hash_bucket *bucket, struct bgp *bgp)
+void update_router_id_vni(struct hash_bucket *bucket, struct bgp *bgp)
 {
 	struct bgpevpn *vpn = (struct bgpevpn *)bucket->data;

@@ -4559,7 +4621,7 @@ static void update_router_id_vni(struct hash_bucket *bucket, struct bgp *bgp)
  * the router-id and is done only on the global route table, the routes
  * are needed in the per-VNI table to re-advertise with new router id.
  */
-static void withdraw_router_id_vni(struct hash_bucket *bucket, struct bgp *bgp)
+void withdraw_router_id_vni(struct hash_bucket *bucket, struct bgp *bgp)
 {
 	struct bgpevpn *vpn = (struct bgpevpn *)bucket->data;

@@ -4574,7 +4636,7 @@ static void withdraw_router_id_vni(struct hash_bucket *bucket, struct bgp *bgp)
  * Create RT-3 for a VNI and schedule for processing and advertisement.
  * This is invoked upon flooding mode changing to head-end replication.
  */
-static void create_advertise_type3(struct hash_bucket *bucket, void *data)
+void create_advertise_type3(struct hash_bucket *bucket, void *data)
 {
 	struct bgpevpn *vpn = bucket->data;
 	struct bgp *bgp = data;
@@ -4595,7 +4657,7 @@ static void create_advertise_type3(struct hash_bucket *bucket, void *data)
  * Delete RT-3 for a VNI and schedule for processing and withdrawal.
  * This is invoked upon flooding mode changing to drop BUM packets.
  */
-static void delete_withdraw_type3(struct hash_bucket *bucket, void *data)
+void delete_withdraw_type3(struct hash_bucket *bucket, void *data)
 {
 	struct bgpevpn *vpn = bucket->data;
 	struct bgp *bgp = data;
@@ -4611,7 +4673,7 @@ static void delete_withdraw_type3(struct hash_bucket *bucket, void *data)
 /*
  * Process received EVPN type-2 route (advertise or withdraw).
  */
-static int process_type2_route(struct peer *peer, afi_t afi, safi_t safi,
+int process_type2_route(struct peer *peer, afi_t afi, safi_t safi,
 			       struct attr *attr, uint8_t *pfx, int psize,
 			       uint32_t addpath_id)
 {
@@ -4740,7 +4802,7 @@ done:
 /*
  * Process received EVPN type-3 route (advertise or withdraw).
  */
-static int process_type3_route(struct peer *peer, afi_t afi, safi_t safi,
+int process_type3_route(struct peer *peer, afi_t afi, safi_t safi,
 			       struct attr *attr, uint8_t *pfx, int psize,
 			       uint32_t addpath_id)
 {
@@ -4821,7 +4883,7 @@ static int process_type3_route(struct peer *peer, afi_t afi, safi_t safi,
 /*
  * Process received EVPN type-5 route (advertise or withdraw).
  */
-static int process_type5_route(struct peer *peer, afi_t afi, safi_t safi,
+int process_type5_route(struct peer *peer, afi_t afi, safi_t safi,
 			       struct attr *attr, uint8_t *pfx, int psize,
 			       uint32_t addpath_id)
 {
@@ -4963,7 +5025,7 @@ static int process_type5_route(struct peer *peer, afi_t afi, safi_t safi,
 	return 0;
 }

-static void evpn_mpattr_encode_type5(struct stream *s, const struct prefix *p,
+void evpn_mpattr_encode_type5(struct stream *s, const struct prefix *p,
 				     const struct prefix_rd *prd,
 				     mpls_label_t *label, uint32_t num_labels,
 				     struct attr *attr)
@@ -5022,7 +5084,7 @@ static void evpn_mpattr_encode_type5(struct stream *s, const struct prefix *p,
 /*
  * Cleanup specific VNI upon EVPN (advertise-all-vni) being disabled.
  */
-static void cleanup_vni_on_disable(struct hash_bucket *bucket, struct bgp *bgp)
+void cleanup_vni_on_disable(struct hash_bucket *bucket, struct bgp *bgp)
 {
 	struct bgpevpn *vpn = (struct bgpevpn *)bucket->data;

@@ -5038,7 +5100,7 @@ static void cleanup_vni_on_disable(struct hash_bucket *bucket, struct bgp *bgp)
 /*
  * Free a VNI entry; iterator function called during cleanup.
  */
-static void free_vni_entry(struct hash_bucket *bucket, struct bgp *bgp)
+void free_vni_entry(struct hash_bucket *bucket, struct bgp *bgp)
 {
 	struct bgpevpn *vpn = (struct bgpevpn *)bucket->data;

@@ -5049,7 +5111,7 @@ static void free_vni_entry(struct hash_bucket *bucket, struct bgp *bgp)
 /*
  * Derive AUTO import RT for BGP VRF - L3VNI
  */
-static void evpn_auto_rt_import_add_for_vrf(struct bgp *bgp_vrf)
+void evpn_auto_rt_import_add_for_vrf(struct bgp *bgp_vrf)
 {
 	struct bgp *bgp_evpn = NULL;

@@ -5067,7 +5129,7 @@ static void evpn_auto_rt_import_add_for_vrf(struct bgp *bgp_vrf)
 /*
  * Delete AUTO import RT from BGP VRF - L3VNI
  */
-static void evpn_auto_rt_import_delete_for_vrf(struct bgp *bgp_vrf)
+void evpn_auto_rt_import_delete_for_vrf(struct bgp *bgp_vrf)
 {
 	evpn_rt_delete_auto(bgp_vrf, bgp_vrf->l3vni, bgp_vrf->vrf_import_rtl,
 			    true);
@@ -5076,7 +5138,7 @@ static void evpn_auto_rt_import_delete_for_vrf(struct bgp *bgp_vrf)
 /*
  * Derive AUTO export RT for BGP VRF - L3VNI
  */
-static void evpn_auto_rt_export_add_for_vrf(struct bgp *bgp_vrf)
+void evpn_auto_rt_export_add_for_vrf(struct bgp *bgp_vrf)
 {
 	form_auto_rt(bgp_vrf, bgp_vrf->l3vni, bgp_vrf->vrf_export_rtl, true);
 }
@@ -5084,13 +5146,13 @@ static void evpn_auto_rt_export_add_for_vrf(struct bgp *bgp_vrf)
 /*
  * Delete AUTO export RT from BGP VRF - L3VNI
  */
-static void evpn_auto_rt_export_delete_for_vrf(struct bgp *bgp_vrf)
+void evpn_auto_rt_export_delete_for_vrf(struct bgp *bgp_vrf)
 {
 	evpn_rt_delete_auto(bgp_vrf, bgp_vrf->l3vni, bgp_vrf->vrf_export_rtl,
 			    true);
 }

-static void bgp_evpn_handle_export_rt_change_for_vrf(struct bgp *bgp_vrf)
+void bgp_evpn_handle_export_rt_change_for_vrf(struct bgp *bgp_vrf)
 {
 	struct bgp *bgp_evpn = NULL;
 	struct listnode *node = NULL;
@@ -5111,7 +5173,7 @@ static void bgp_evpn_handle_export_rt_change_for_vrf(struct bgp *bgp_vrf)
 /*
  * Handle autort change for a given VNI.
  */
-static void update_autort_vni(struct hash_bucket *bucket, struct bgp *bgp)
+void update_autort_vni(struct hash_bucket *bucket, struct bgp *bgp)
 {
 	struct bgpevpn *vpn = bucket->data;

@@ -5135,7 +5197,7 @@ static void update_autort_vni(struct hash_bucket *bucket, struct bgp *bgp)
 /*
  * Handle autort change for L3VNI.
  */
-static void update_autort_l3vni(struct bgp *bgp)
+void update_autort_l3vni(struct bgp *bgp)
 {
 	if ((CHECK_FLAG(bgp->vrf_flags, BGP_VRF_IMPORT_RT_CFGD))
 	    && (CHECK_FLAG(bgp->vrf_flags, BGP_VRF_EXPORT_RT_CFGD)))
@@ -5330,7 +5392,7 @@ void bgp_evpn_advertise_type5_routes(struct bgp *bgp_vrf, afi_t afi,
 	}
 }

-static void rt_list_remove_node(struct list *rt_list,
+void rt_list_remove_node(struct list *rt_list,
 				struct ecommunity *ecomdel, bool is_l3)
 {
 	struct listnode *node = NULL, *nnode = NULL, *node_to_del = NULL;
@@ -5379,7 +5441,7 @@ void evpn_rt_delete_auto(struct bgp *bgp, vni_t vni, struct list *rtl,
 	ecommunity_free(&ecom_auto);
 }

-static void evpn_vrf_rt_routes_map(struct bgp *bgp_vrf)
+void evpn_vrf_rt_routes_map(struct bgp *bgp_vrf)
 {
 	/* map VRFs to its RTs and install routes matching this new RT */
 	if (is_l3vni_live(bgp_vrf)) {
@@ -5388,7 +5450,7 @@ static void evpn_vrf_rt_routes_map(struct bgp *bgp_vrf)
 	}
 }

-static void evpn_vrf_rt_routes_unmap(struct bgp *bgp_vrf)
+void evpn_vrf_rt_routes_unmap(struct bgp *bgp_vrf)
 {
 	/* uninstall routes from vrf */
 	if (is_l3vni_live(bgp_vrf))
@@ -5398,7 +5460,7 @@ static void evpn_vrf_rt_routes_unmap(struct bgp *bgp_vrf)
 	bgp_evpn_unmap_vrf_from_its_rts(bgp_vrf);
 }

-static bool rt_list_has_cfgd_rt(struct list *rt_list)
+bool rt_list_has_cfgd_rt(struct list *rt_list)
 {
 	struct listnode *node = NULL, *nnode = NULL;
 	struct vrf_route_target *l3rt = NULL;
@@ -5411,7 +5473,7 @@ static bool rt_list_has_cfgd_rt(struct list *rt_list)
 	return false;
 }

-static void unconfigure_import_rt_for_vrf_fini(struct bgp *bgp_vrf)
+void unconfigure_import_rt_for_vrf_fini(struct bgp *bgp_vrf)
 {
 	if (!bgp_vrf->vrf_import_rtl)
 		return; /* this should never fail */
@@ -5424,7 +5486,7 @@ static void unconfigure_import_rt_for_vrf_fini(struct bgp *bgp_vrf)
 		evpn_auto_rt_import_add_for_vrf(bgp_vrf);
 }

-static void unconfigure_export_rt_for_vrf_fini(struct bgp *bgp_vrf)
+void unconfigure_export_rt_for_vrf_fini(struct bgp *bgp_vrf)
 {

 	if (!bgp_vrf->vrf_export_rtl)
@@ -6262,6 +6324,16 @@ struct bgpevpn *bgp_evpn_new(struct bgp *bgp, vni_t vni,
  */
 void bgp_evpn_free(struct bgp *bgp, struct bgpevpn *vpn)
 {
+	struct bgp_dest *dest = NULL;
+
+	while (zebra_announce_count(&bm->zebra_announce_head)) {
+		dest = zebra_announce_pop(&bm->zebra_announce_head);
+		if (dest->za_vpn == vpn) {
+			bgp_path_info_unlock(dest->za_bgp_pi);
+			bgp_dest_unlock_node(dest);
+		} else
+			zebra_announce_add_tail(&bm->zebra_announce_head, dest);
+	}
 	bgp_evpn_remote_ip_hash_destroy(vpn);
 	bgp_evpn_vni_es_cleanup(vpn);
 	bgpevpn_unlink_from_l3vni(vpn);
@@ -6279,7 +6351,7 @@ void bgp_evpn_free(struct bgp *bgp, struct bgpevpn *vpn)
 	XFREE(MTYPE_BGP_EVPN, vpn);
 }

-static void hash_evpn_free(struct bgpevpn *vpn)
+void hash_evpn_free(struct bgpevpn *vpn)
 {
 	XFREE(MTYPE_BGP_EVPN, vpn);
 }
@@ -6646,7 +6718,7 @@ int bgp_evpn_local_macip_add(struct bgp *bgp, vni_t vni, struct ethaddr *mac,
 	return 0;
 }

-static void link_l2vni_hash_to_l3vni(struct hash_bucket *bucket,
+void link_l2vni_hash_to_l3vni(struct hash_bucket *bucket,
 				     struct bgp *bgp_vrf)
 {
 	struct bgpevpn *vpn = (struct bgpevpn *)bucket->data;
@@ -7265,7 +7337,7 @@ bool bgp_evpn_is_prefix_nht_supported(const struct prefix *pfx)
 	return false;
 }

-static void *bgp_evpn_remote_ip_hash_alloc(void *p)
+void *bgp_evpn_remote_ip_hash_alloc(void *p)
 {
 	const struct evpn_remote_ip *key = (const struct evpn_remote_ip *)p;
 	struct evpn_remote_ip *ip;
@@ -7277,7 +7349,7 @@ static void *bgp_evpn_remote_ip_hash_alloc(void *p)
 	return ip;
 }

-static unsigned int bgp_evpn_remote_ip_hash_key_make(const void *p)
+unsigned int  bgp_evpn_remote_ip_hash_key_make(const void *p)
 {
 	const struct evpn_remote_ip *ip = p;
 	const struct ipaddr *addr = &ip->addr;
@@ -7289,7 +7361,7 @@ static unsigned int bgp_evpn_remote_ip_hash_key_make(const void *p)
 		      array_size(addr->ipaddr_v6.s6_addr32), 0);
 }

-static bool bgp_evpn_remote_ip_hash_cmp(const void *p1, const void *p2)
+bool bgp_evpn_remote_ip_hash_cmp(const void *p1, const void *p2)
 {
 	const struct evpn_remote_ip *ip1 = p1;
 	const struct evpn_remote_ip *ip2 = p2;
@@ -7297,7 +7369,7 @@ static bool bgp_evpn_remote_ip_hash_cmp(const void *p1, const void *p2)
 	return !ipaddr_cmp(&ip1->addr, &ip2->addr);
 }

-static void bgp_evpn_remote_ip_hash_init(struct bgpevpn *vpn)
+void bgp_evpn_remote_ip_hash_init(struct bgpevpn *vpn)
 {
 	if (!evpn_resolve_overlay_index())
 		return;
@@ -7307,7 +7379,7 @@ static void bgp_evpn_remote_ip_hash_init(struct bgpevpn *vpn)
 					  "BGP EVPN remote IP hash");
 }

-static void bgp_evpn_remote_ip_hash_free(struct hash_bucket *bucket, void *args)
+void bgp_evpn_remote_ip_hash_free(struct hash_bucket *bucket, void *args)
 {
 	struct evpn_remote_ip *ip = (struct evpn_remote_ip *)bucket->data;
 	struct bgpevpn *vpn = (struct bgpevpn *)args;
@@ -7320,7 +7392,7 @@ static void bgp_evpn_remote_ip_hash_free(struct hash_bucket *bucket, void *args)
 	XFREE(MTYPE_EVPN_REMOTE_IP, ip);
 }

-static void bgp_evpn_remote_ip_hash_destroy(struct bgpevpn *vpn)
+void bgp_evpn_remote_ip_hash_destroy(struct bgpevpn *vpn)
 {
 	if (!evpn_resolve_overlay_index() || vpn->remote_ip_hash == NULL)
 		return;
@@ -7334,7 +7406,7 @@ static void bgp_evpn_remote_ip_hash_destroy(struct bgpevpn *vpn)
 }

 /* Add a remote MAC/IP route to hash table */
-static void bgp_evpn_remote_ip_hash_add(struct bgpevpn *vpn,
+void bgp_evpn_remote_ip_hash_add(struct bgpevpn *vpn,
 					struct bgp_path_info *pi)
 {
 	struct evpn_remote_ip tmp;
@@ -7371,7 +7443,7 @@ static void bgp_evpn_remote_ip_hash_add(struct bgpevpn *vpn,
 }

 /* Delete a remote MAC/IP route from hash table */
-static void bgp_evpn_remote_ip_hash_del(struct bgpevpn *vpn,
+void bgp_evpn_remote_ip_hash_del(struct bgpevpn *vpn,
 					struct bgp_path_info *pi)
 {
 	struct evpn_remote_ip tmp;
@@ -7403,7 +7475,7 @@ static void bgp_evpn_remote_ip_hash_del(struct bgpevpn *vpn,
 	}
 }

-static void bgp_evpn_remote_ip_hash_iterate(struct bgpevpn *vpn,
+void bgp_evpn_remote_ip_hash_iterate(struct bgpevpn *vpn,
 					    void (*func)(struct hash_bucket *,
 							 void *),
 					    void *arg)
@@ -7414,7 +7486,7 @@ static void bgp_evpn_remote_ip_hash_iterate(struct bgpevpn *vpn,
 	hash_iterate(vpn->remote_ip_hash, func, arg);
 }

-static void show_remote_ip_entry(struct hash_bucket *bucket, void *args)
+void show_remote_ip_entry(struct hash_bucket *bucket, void *args)
 {
 	char buf[INET6_ADDRSTRLEN];
 	struct listnode *node = NULL;
@@ -7442,7 +7514,7 @@ void bgp_evpn_show_remote_ip_hash(struct hash_bucket *bucket, void *args)
 	vty_out(vty, "\n");
 }

-static void bgp_evpn_remote_ip_hash_link_nexthop(struct hash_bucket *bucket,
+void bgp_evpn_remote_ip_hash_link_nexthop(struct hash_bucket *bucket,
 						 void *args)
 {
 	struct evpn_remote_ip *ip = (struct evpn_remote_ip *)bucket->data;
@@ -7451,7 +7523,7 @@ static void bgp_evpn_remote_ip_hash_link_nexthop(struct hash_bucket *bucket,
 	bgp_evpn_remote_ip_process_nexthops(vpn, &ip->addr, true);
 }

-static void bgp_evpn_remote_ip_hash_unlink_nexthop(struct hash_bucket *bucket,
+void bgp_evpn_remote_ip_hash_unlink_nexthop(struct hash_bucket *bucket,
 						   void *args)
 {
 	struct evpn_remote_ip *ip = (struct evpn_remote_ip *)bucket->data;
@@ -7460,14 +7532,14 @@ static void bgp_evpn_remote_ip_hash_unlink_nexthop(struct hash_bucket *bucket,
 	bgp_evpn_remote_ip_process_nexthops(vpn, &ip->addr, false);
 }

-static unsigned int vni_svi_hash_key_make(const void *p)
+unsigned int  vni_svi_hash_key_make(const void *p)
 {
 	const struct bgpevpn *vpn = p;

 	return jhash_1word(vpn->svi_ifindex, 0);
 }

-static bool vni_svi_hash_cmp(const void *p1, const void *p2)
+bool vni_svi_hash_cmp(const void *p1, const void *p2)
 {
 	const struct bgpevpn *vpn1 = p1;
 	const struct bgpevpn *vpn2 = p2;
@@ -7475,7 +7547,7 @@ static bool vni_svi_hash_cmp(const void *p1, const void *p2)
 	return (vpn1->svi_ifindex == vpn2->svi_ifindex);
 }

-static struct bgpevpn *bgp_evpn_vni_svi_hash_lookup(struct bgp *bgp,
+struct bgpevpn *bgp_evpn_vni_svi_hash_lookup(struct bgp *bgp,
 						    ifindex_t svi)
 {
 	struct bgpevpn *vpn;
@@ -7487,7 +7559,7 @@ static struct bgpevpn *bgp_evpn_vni_svi_hash_lookup(struct bgp *bgp,
 	return vpn;
 }

-static void bgp_evpn_link_to_vni_svi_hash(struct bgp *bgp, struct bgpevpn *vpn)
+void bgp_evpn_link_to_vni_svi_hash(struct bgp *bgp, struct bgpevpn *vpn)
 {
 	if (vpn->svi_ifindex == 0)
 		return;
@@ -7495,7 +7567,7 @@ static void bgp_evpn_link_to_vni_svi_hash(struct bgp *bgp, struct bgpevpn *vpn)
 	(void)hash_get(bgp->vni_svi_hash, vpn, hash_alloc_intern);
 }

-static void bgp_evpn_unlink_from_vni_svi_hash(struct bgp *bgp,
+void bgp_evpn_unlink_from_vni_svi_hash(struct bgp *bgp,
 					      struct bgpevpn *vpn)
 {
 	if (vpn->svi_ifindex == 0)
@@ -7572,7 +7644,7 @@ bool bgp_evpn_is_gateway_ip_resolved(struct bgp_nexthop_cache *bnc)
 }

 /* Resolve/Unresolve nexthops when a MAC/IP route is added/deleted */
-static void bgp_evpn_remote_ip_process_nexthops(struct bgpevpn *vpn,
+void bgp_evpn_remote_ip_process_nexthops(struct bgpevpn *vpn,
 						struct ipaddr *addr,
 						bool resolve)
 {
@@ -7695,7 +7767,7 @@ vni_t bgp_evpn_path_info_get_l3vni(const struct bgp_path_info *pi)
 /*
  * Returns true if the l3vni of any of this path doesn't match vrf's l3vni.
  */
-static bool bgp_evpn_path_is_dvni(const struct bgp *bgp_vrf,
+bool bgp_evpn_path_is_dvni(const struct bgp *bgp_vrf,
 				  const struct bgp_path_info *pi)
 {
 	vni_t vni = 0;
@@ -7781,4 +7853,5 @@ void bgp_aggr_supp_withdraw_from_evpn(struct bgp *bgp, afi_t afi, safi_t safi)
 			}
 		}
 	}
-}
+	return;
+}
\ No newline at end of file
diff --git a/bgpd/bgp_evpn.h b/bgpd/bgp_evpn.h
index c641a64f6..db05293a4 100644
--- a/bgpd/bgp_evpn.h
+++ b/bgpd/bgp_evpn.h
@@ -176,6 +176,14 @@ bgp_evpn_handle_resolve_overlay_index_set(struct hash_bucket *bucket,
 extern void
 bgp_evpn_handle_resolve_overlay_index_unset(struct hash_bucket *bucket,
 					    void *arg);
+extern enum zclient_send_status evpn_zebra_install(struct bgp *bgp,
+					   struct bgpevpn *vpn,
+					   const struct prefix_evpn *p,
+					   struct bgp_path_info *pi);
+extern enum zclient_send_status
+evpn_zebra_uninstall(struct bgp *bgp, struct bgpevpn *vpn,
+		     const struct prefix_evpn *p, struct bgp_path_info *pi,
+		     bool is_sync);
 extern mpls_label_t *bgp_evpn_path_info_labels_get_l3vni(mpls_label_t *labels,
 							 uint32_t num_labels);
 extern vni_t bgp_evpn_path_info_get_l3vni(const struct bgp_path_info *pi);
diff --git a/bgpd/bgp_evpn_mh.c b/bgpd/bgp_evpn_mh.c
index d88c52d1f..f36d109b6 100644
--- a/bgpd/bgp_evpn_mh.c
+++ b/bgpd/bgp_evpn_mh.c
@@ -49,8 +49,8 @@ static struct bgp_evpn_es_vtep *bgp_evpn_es_vtep_add(struct bgp *bgp,
 						     struct bgp_evpn_es *es,
 						     struct in_addr vtep_ip,
 						     bool esr, uint8_t df_alg,
-						     uint16_t df_pref);
-static void bgp_evpn_es_vtep_del(struct bgp *bgp,
+						     uint16_t df_pref, int *zret);
+static enum zclient_send_status bgp_evpn_es_vtep_del(struct bgp *bgp,
 		struct bgp_evpn_es *es, struct in_addr vtep_ip, bool esr);
 static void bgp_evpn_es_cons_checks_pend_add(struct bgp_evpn_es *es);
 static void bgp_evpn_es_cons_checks_pend_del(struct bgp_evpn_es *es);
@@ -94,6 +94,7 @@ static int bgp_evpn_es_route_select_install(struct bgp *bgp,
 					    struct bgp_dest *dest)
 {
 	int ret = 0;
+	int zret = 0;
 	afi_t afi = AFI_L2VPN;
 	safi_t safi = SAFI_EVPN;
 	struct bgp_path_info *old_select; /* old best */
@@ -120,7 +121,7 @@ static int bgp_evpn_es_route_select_install(struct bgp *bgp,
 			bgp_evpn_es_vtep_add(bgp, es, old_select->attr->nexthop,
 					     true /*esr*/,
 					     old_select->attr->df_alg,
-					     old_select->attr->df_pref);
+					     old_select->attr->df_pref, &zret);
 		}
 		UNSET_FLAG(old_select->flags, BGP_PATH_MULTIPATH_CHG);
 		bgp_zebra_clear_route_change_flags(dest);
@@ -149,7 +150,7 @@ static int bgp_evpn_es_route_select_install(struct bgp *bgp,
 			&& new_select->sub_type == BGP_ROUTE_IMPORTED) {
 		bgp_evpn_es_vtep_add(bgp, es, new_select->attr->nexthop,
 				     true /*esr */, new_select->attr->df_alg,
-				     new_select->attr->df_pref);
+				     new_select->attr->df_pref, &zret);
 	} else {
 		if (old_select && old_select->type == ZEBRA_ROUTE_BGP
 				&& old_select->sub_type == BGP_ROUTE_IMPORTED)
@@ -1371,23 +1372,26 @@ static struct bgp_evpn_es_vtep *bgp_evpn_es_vtep_find(struct bgp_evpn_es *es,
 }

 /* Send the remote ES to zebra for NHG programming */
-static int bgp_zebra_send_remote_es_vtep(struct bgp *bgp,
+static enum zclient_send_status bgp_zebra_send_remote_es_vtep(struct bgp *bgp,
 		struct bgp_evpn_es_vtep *es_vtep, bool add)
 {
 	struct bgp_evpn_es *es = es_vtep->es;
 	struct stream *s;
 	uint32_t flags = 0;

-	/* Check socket. */
-	if (!zclient || zclient->sock < 0)
-		return 0;
+	if (!zclient || zclient->sock < 0) {
+		if (BGP_DEBUG(zebra, ZEBRA))
+			zlog_debug("%s: No zclient or zclient->sock exists",
+				   __func__);
+		return ZCLIENT_SEND_SUCCESS;
+	}

 	/* Don't try to register if Zebra doesn't know of this instance. */
 	if (!IS_BGP_INST_KNOWN_TO_ZEBRA(bgp)) {
 		if (BGP_DEBUG(zebra, ZEBRA))
 			zlog_debug("No zebra instance, not installing remote es %s",
 					es->esi_str);
-		return 0;
+		return ZCLIENT_SEND_SUCCESS;
 	}

 	if (es_vtep->flags & BGP_EVPNES_VTEP_ESR)
@@ -1418,12 +1422,13 @@ static int bgp_zebra_send_remote_es_vtep(struct bgp *bgp,
 	return zclient_send_message(zclient);
 }

-static void bgp_evpn_es_vtep_re_eval_active(struct bgp *bgp,
+static enum zclient_send_status bgp_evpn_es_vtep_re_eval_active(struct bgp *bgp,
 					    struct bgp_evpn_es_vtep *es_vtep,
 					    bool param_change)
 {
 	bool old_active;
 	bool new_active;
+	enum zclient_send_status ret = ZCLIENT_SEND_SUCCESS;

 	old_active = CHECK_FLAG(es_vtep->flags, BGP_EVPNES_VTEP_ACTIVE);
 	/* currently we need an active EVI reference to use the VTEP as
@@ -1445,7 +1450,7 @@ static void bgp_evpn_es_vtep_re_eval_active(struct bgp *bgp,
 				   es_vtep->df_alg, es_vtep->df_pref);

 		/* send remote ES to zebra */
-		bgp_zebra_send_remote_es_vtep(bgp, es_vtep, new_active);
+		ret = bgp_zebra_send_remote_es_vtep(bgp, es_vtep, new_active);

 		/* The NHG is updated first for efficient failover handling.
 		 * Note the NHG can be de-activated while there are bgp
@@ -1457,13 +1462,14 @@ static void bgp_evpn_es_vtep_re_eval_active(struct bgp *bgp,
 		/* queue up the es for background consistency checks */
 		bgp_evpn_es_cons_checks_pend_add(es_vtep->es);
 	}
+	return ret;
 }

 static struct bgp_evpn_es_vtep *bgp_evpn_es_vtep_add(struct bgp *bgp,
 						     struct bgp_evpn_es *es,
 						     struct in_addr vtep_ip,
 						     bool esr, uint8_t df_alg,
-						     uint16_t df_pref)
+						     uint16_t df_pref, int *zret)
 {
 	struct bgp_evpn_es_vtep *es_vtep;
 	bool param_change = false;
@@ -1490,15 +1496,16 @@ static struct bgp_evpn_es_vtep *bgp_evpn_es_vtep_add(struct bgp *bgp,
 		++es_vtep->evi_cnt;
 	}

-	bgp_evpn_es_vtep_re_eval_active(bgp, es_vtep, param_change);
+	*zret = bgp_evpn_es_vtep_re_eval_active(bgp, es_vtep, param_change);

 	return es_vtep;
 }

-static void bgp_evpn_es_vtep_do_del(struct bgp *bgp,
+static enum zclient_send_status bgp_evpn_es_vtep_do_del(struct bgp *bgp,
 		struct bgp_evpn_es_vtep *es_vtep, bool esr)
 {
 	bool param_change = false;
+	enum zclient_send_status ret = ZCLIENT_SEND_SUCCESS;

 	if (BGP_DEBUG(evpn_mh, EVPN_MH_ES))
 		zlog_debug("es %s vtep %pI4 del %s", es_vtep->es->esi_str,
@@ -1515,18 +1522,21 @@ static void bgp_evpn_es_vtep_do_del(struct bgp *bgp,
 			--es_vtep->evi_cnt;
 	}

-	bgp_evpn_es_vtep_re_eval_active(bgp, es_vtep, param_change);
+	ret = bgp_evpn_es_vtep_re_eval_active(bgp, es_vtep, param_change);
 	bgp_evpn_es_vtep_free(es_vtep);
+	return ret;
 }

-static void bgp_evpn_es_vtep_del(struct bgp *bgp,
+static enum zclient_send_status bgp_evpn_es_vtep_del(struct bgp *bgp,
 		struct bgp_evpn_es *es, struct in_addr vtep_ip, bool esr)
 {
 	struct bgp_evpn_es_vtep *es_vtep;
+	enum zclient_send_status ret = ZCLIENT_SEND_SUCCESS;

 	es_vtep = bgp_evpn_es_vtep_find(es, vtep_ip);
 	if (es_vtep)
-		bgp_evpn_es_vtep_do_del(bgp, es_vtep, esr);
+		ret = bgp_evpn_es_vtep_do_del(bgp, es_vtep, esr);
+	return ret;
 }

 /********************** ES MAC-IP paths *************************************
@@ -3399,12 +3409,13 @@ static struct bgp_evpn_es_evi_vtep *bgp_evpn_es_evi_vtep_find(
 /* A VTEP can be added as "active" attach to an ES if EAD-per-ES and
  * EAD-per-EVI routes are rxed from it.
  */
-static void bgp_evpn_es_evi_vtep_re_eval_active(struct bgp *bgp,
+static enum zclient_send_status bgp_evpn_es_evi_vtep_re_eval_active(struct bgp *bgp,
 		struct bgp_evpn_es_evi_vtep *evi_vtep)
 {
 	bool old_active;
 	bool new_active;
 	uint32_t ead_activity_flags;
+	enum zclient_send_status ret = ZCLIENT_SEND_SUCCESS;

 	old_active = CHECK_FLAG(evi_vtep->flags, BGP_EVPN_EVI_VTEP_ACTIVE);

@@ -3425,7 +3436,7 @@ static void bgp_evpn_es_evi_vtep_re_eval_active(struct bgp *bgp,
 	new_active = CHECK_FLAG(evi_vtep->flags, BGP_EVPN_EVI_VTEP_ACTIVE);

 	if (old_active == new_active)
-		return;
+		return ret;

 	if (BGP_DEBUG(evpn_mh, EVPN_MH_ES))
 		zlog_debug("es %s evi %u vtep %pI4 %s",
@@ -3437,19 +3448,20 @@ static void bgp_evpn_es_evi_vtep_re_eval_active(struct bgp *bgp,
 	if (new_active)
 		evi_vtep->es_vtep = bgp_evpn_es_vtep_add(
 			bgp, evi_vtep->es_evi->es, evi_vtep->vtep_ip,
-			false /*esr*/, 0, 0);
+			false /*esr*/, 0, 0, &ret);
 	else {
 		if (evi_vtep->es_vtep) {
-			bgp_evpn_es_vtep_do_del(bgp, evi_vtep->es_vtep,
+			ret = bgp_evpn_es_vtep_do_del(bgp, evi_vtep->es_vtep,
 					false /*esr*/);
 			evi_vtep->es_vtep = NULL;
 		}
 	}
 	/* queue up the parent es for background consistency checks */
 	bgp_evpn_es_cons_checks_pend_add(evi_vtep->es_evi->es);
+	return ret;
 }

-static void bgp_evpn_es_evi_vtep_add(struct bgp *bgp,
+static enum zclient_send_status bgp_evpn_es_evi_vtep_add(struct bgp *bgp,
 		struct bgp_evpn_es_evi *es_evi, struct in_addr vtep_ip,
 		bool ead_es)
 {
@@ -3475,18 +3487,19 @@ static void bgp_evpn_es_evi_vtep_add(struct bgp *bgp,
 	else
 		SET_FLAG(evi_vtep->flags, BGP_EVPN_EVI_VTEP_EAD_PER_EVI);

-	bgp_evpn_es_evi_vtep_re_eval_active(bgp, evi_vtep);
+	return bgp_evpn_es_evi_vtep_re_eval_active(bgp, evi_vtep);
 }

-static void bgp_evpn_es_evi_vtep_del(struct bgp *bgp,
+static enum zclient_send_status bgp_evpn_es_evi_vtep_del(struct bgp *bgp,
 		struct bgp_evpn_es_evi *es_evi, struct in_addr vtep_ip,
 		bool ead_es)
 {
 	struct bgp_evpn_es_evi_vtep *evi_vtep;
+	enum zclient_send_status ret = ZCLIENT_SEND_SUCCESS;

 	evi_vtep = bgp_evpn_es_evi_vtep_find(es_evi, vtep_ip);
 	if (!evi_vtep)
-		return;
+		return ret;

 	if (BGP_DEBUG(evpn_mh, EVPN_MH_ES))
 		zlog_debug("del es %s evi %u vtep %pI4 %s",
@@ -3503,8 +3516,9 @@ static void bgp_evpn_es_evi_vtep_del(struct bgp *bgp,
 	else
 		UNSET_FLAG(evi_vtep->flags, BGP_EVPN_EVI_VTEP_EAD_PER_EVI);

-	bgp_evpn_es_evi_vtep_re_eval_active(bgp, evi_vtep);
+	ret = bgp_evpn_es_evi_vtep_re_eval_active(bgp, evi_vtep);
 	bgp_evpn_es_evi_vtep_free(evi_vtep);
+	return ret;
 }

 /* compare ES-IDs for the ES-EVI RB tree maintained per-VNI */
@@ -3780,7 +3794,7 @@ int bgp_evpn_local_es_evi_add(struct bgp *bgp, esi_t *esi, vni_t vni)
 /* Add remote ES-EVI entry. This is actually the remote VTEP add and the
  * ES-EVI is implicity created on first VTEP's reference.
  */
-int bgp_evpn_remote_es_evi_add(struct bgp *bgp, struct bgpevpn *vpn,
+enum zclient_send_status bgp_evpn_remote_es_evi_add(struct bgp *bgp, struct bgpevpn *vpn,
 		const struct prefix_evpn *p)
 {
 	char buf[ESI_STR_LEN];
@@ -3788,10 +3802,11 @@ int bgp_evpn_remote_es_evi_add(struct bgp *bgp, struct bgpevpn *vpn,
 	struct bgp_evpn_es_evi *es_evi;
 	bool ead_es;
 	const esi_t *esi = &p->prefix.ead_addr.esi;
+	enum zclient_send_status ret = ZCLIENT_SEND_SUCCESS;

 	if (!vpn)
 		/* local EAD-ES need not be sent back to zebra */
-		return 0;
+		return ret;

 	if (BGP_DEBUG(evpn_mh, EVPN_MH_ES))
 		zlog_debug("add remote %s es %s evi %u vtep %pI4",
@@ -3808,27 +3823,28 @@ int bgp_evpn_remote_es_evi_add(struct bgp *bgp, struct bgpevpn *vpn,
 		es_evi = bgp_evpn_es_evi_new(es, vpn);

 	ead_es = !!p->prefix.ead_addr.eth_tag;
-	bgp_evpn_es_evi_vtep_add(bgp, es_evi, p->prefix.ead_addr.ip.ipaddr_v4,
+	ret = bgp_evpn_es_evi_vtep_add(bgp, es_evi, p->prefix.ead_addr.ip.ipaddr_v4,
 			ead_es);

 	bgp_evpn_es_evi_remote_info_re_eval(es_evi);
-	return 0;
+	return ret;
 }

 /* A remote VTEP has withdrawn. The es-evi-vtep will be deleted and the
  * parent es-evi freed up implicitly in last VTEP's deref.
  */
-int bgp_evpn_remote_es_evi_del(struct bgp *bgp, struct bgpevpn *vpn,
+enum zclient_send_status bgp_evpn_remote_es_evi_del(struct bgp *bgp, struct bgpevpn *vpn,
 		const struct prefix_evpn *p)
 {
 	char buf[ESI_STR_LEN];
 	struct bgp_evpn_es *es;
 	struct bgp_evpn_es_evi *es_evi;
 	bool ead_es;
+	enum zclient_send_status ret = ZCLIENT_SEND_SUCCESS;

 	if (!vpn)
 		/* local EAD-ES need not be sent back to zebra */
-		return 0;
+		return ret;

 	if (BGP_DEBUG(evpn_mh, EVPN_MH_ES))
 		zlog_debug(
@@ -3847,7 +3863,7 @@ int bgp_evpn_remote_es_evi_del(struct bgp *bgp, struct bgpevpn *vpn,
 				esi_to_str(&p->prefix.ead_addr.esi, buf,
 					   sizeof(buf)),
 				vpn->vni, &p->prefix.ead_addr.ip.ipaddr_v4);
-		return 0;
+		return ret;
 	}
 	es_evi = bgp_evpn_es_evi_find(es, vpn);
 	if (!es_evi) {
@@ -3860,14 +3876,14 @@ int bgp_evpn_remote_es_evi_del(struct bgp *bgp, struct bgpevpn *vpn,
 					   sizeof(buf)),
 				vpn->vni,
 				&p->prefix.ead_addr.ip.ipaddr_v4);
-		return 0;
+		return ret;
 	}

 	ead_es = !!p->prefix.ead_addr.eth_tag;
-	bgp_evpn_es_evi_vtep_del(bgp, es_evi, p->prefix.ead_addr.ip.ipaddr_v4,
+	ret = bgp_evpn_es_evi_vtep_del(bgp, es_evi, p->prefix.ead_addr.ip.ipaddr_v4,
 			ead_es);
 	bgp_evpn_es_evi_remote_info_re_eval(es_evi);
-	return 0;
+	return ret;
 }

 /* If a VNI is being deleted we need to force del all remote VTEPs */
diff --git a/bgpd/bgp_evpn_mh.h b/bgpd/bgp_evpn_mh.h
index cebabb9fd..5d393c37a 100644
--- a/bgpd/bgp_evpn_mh.h
+++ b/bgpd/bgp_evpn_mh.h
@@ -418,10 +418,12 @@ extern int bgp_evpn_local_es_add(struct bgp *bgp, esi_t *esi,
 extern int bgp_evpn_local_es_del(struct bgp *bgp, esi_t *esi);
 extern int bgp_evpn_local_es_evi_add(struct bgp *bgp, esi_t *esi, vni_t vni);
 extern int bgp_evpn_local_es_evi_del(struct bgp *bgp, esi_t *esi, vni_t vni);
-extern int bgp_evpn_remote_es_evi_add(struct bgp *bgp, struct bgpevpn *vpn,
-		const struct prefix_evpn *p);
-extern int bgp_evpn_remote_es_evi_del(struct bgp *bgp, struct bgpevpn *vpn,
-		const struct prefix_evpn *p);
+extern enum zclient_send_status
+bgp_evpn_remote_es_evi_add(struct bgp *bgp, struct bgpevpn *vpn,
+			   const struct prefix_evpn *p);
+extern enum zclient_send_status
+bgp_evpn_remote_es_evi_del(struct bgp *bgp, struct bgpevpn *vpn,
+			   const struct prefix_evpn *p);
 extern void bgp_evpn_mh_init(void);
 extern void bgp_evpn_mh_finish(void);
 void bgp_evpn_vni_es_init(struct bgpevpn *vpn);
diff --git a/bgpd/bgp_route.c b/bgpd/bgp_route.c
index e45d4b1ff..3dff073a3 100644
--- a/bgpd/bgp_route.c
+++ b/bgpd/bgp_route.c
@@ -3420,7 +3420,7 @@ static void bgp_process_main_one(struct bgp *bgp, struct bgp_dest *dest,
 						   == BGP_ROUTE_IMPORTED))

 					bgp_zebra_route_install(dest, old_select,
-							   bgp, true);
+							   bgp, true, NULL, false);
 			}
 		}

@@ -3529,9 +3529,9 @@ static void bgp_process_main_one(struct bgp *bgp, struct bgp_dest *dest,
 			 */
 			if (old_select &&
 			    is_route_parent_evpn(old_select))
-				bgp_zebra_route_install(dest, old_select, bgp, false);
+				bgp_zebra_route_install(dest, old_select, bgp, false, NULL, false);

-			bgp_zebra_route_install(dest, new_select, bgp, true);
+			bgp_zebra_route_install(dest, new_select, bgp, true, NULL, false);
 		} else {
 			/* Withdraw the route from the kernel. */
 			if (old_select && old_select->type == ZEBRA_ROUTE_BGP
@@ -3539,7 +3539,7 @@ static void bgp_process_main_one(struct bgp *bgp, struct bgp_dest *dest,
 				|| old_select->sub_type == BGP_ROUTE_AGGREGATE
 				|| old_select->sub_type == BGP_ROUTE_IMPORTED))

-				bgp_zebra_route_install(dest, old_select, bgp, false);
+				bgp_zebra_route_install(dest, old_select, bgp, false, NULL, false);
 		}
 	}

@@ -4444,7 +4444,7 @@ void bgp_update(struct peer *peer, const struct prefix *p, uint32_t addpath_id,
 	if (pi && pi->attr->rmap_table_id != new_attr.rmap_table_id) {
 		if (CHECK_FLAG(pi->flags, BGP_PATH_SELECTED))
 			/* remove from RIB previous entry */
-			bgp_zebra_route_install(dest, pi, bgp, false);
+			bgp_zebra_route_install(dest, pi, bgp, false, NULL, false);
 	}

 	if (peer->sort == BGP_PEER_EBGP) {
diff --git a/bgpd/bgp_table.h b/bgpd/bgp_table.h
index 67431ea4f..1550d00ad 100644
--- a/bgpd/bgp_table.h
+++ b/bgpd/bgp_table.h
@@ -75,10 +75,10 @@ struct bgp_dest {
 	struct bgp_dest *pdest;

 	STAILQ_ENTRY(bgp_dest) pq;
-	struct bgp_path_info *za_bgp_pi;
-
 	struct zebra_announce_item zai;
-
+	struct bgp_path_info *za_bgp_pi;
+	struct bgpevpn *za_vpn;
+	bool za_is_sync;
 	uint64_t version;

 	mpls_label_t local_label;
diff --git a/bgpd/bgp_zebra.c b/bgpd/bgp_zebra.c
index 064f23350..cab758fca 100644
--- a/bgpd/bgp_zebra.c
+++ b/bgpd/bgp_zebra.c
@@ -1674,7 +1674,7 @@ void bgp_zebra_announce_table(struct bgp *bgp, afi_t afi, safi_t safi)
 			     && (pi->sub_type == BGP_ROUTE_NORMAL
 				 || pi->sub_type == BGP_ROUTE_IMPORTED)))

-				bgp_zebra_route_install(dest, pi, bgp, true);
+				bgp_zebra_route_install(dest, pi, bgp, true, NULL, false);
 }

 /* Announce routes of any bgp subtype of a table to zebra */
@@ -1696,7 +1696,7 @@ void bgp_zebra_announce_table_all_subtypes(struct bgp *bgp, afi_t afi,
 		for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next)
 			if (CHECK_FLAG(pi->flags, BGP_PATH_SELECTED) &&
 			    pi->type == ZEBRA_ROUTE_BGP)
-				bgp_zebra_route_install(dest, pi, bgp, true);
+				bgp_zebra_route_install(dest, pi, bgp, true, NULL, false);
 }


@@ -1749,6 +1749,7 @@ enum zclient_send_status bgp_zebra_withdraw_actual(struct bgp_dest *dest,
 #define ZEBRA_ANNOUNCEMENTS_LIMIT 1000
 static void bgp_handle_route_announcements_to_zebra(struct thread *e)
 {
+	bool is_evpn = false;
 	uint32_t count = 0;
 	struct bgp_dest *dest = NULL;
 	struct bgp_table *table = NULL;
@@ -1764,6 +1765,9 @@ static void bgp_handle_route_announcements_to_zebra(struct thread *e)
 		table = bgp_dest_table(dest);
 		install =
 			CHECK_FLAG(dest->flags, BGP_NODE_SCHEDULE_FOR_INSTALL);
+		if (table && table->afi == AFI_L2VPN &&
+		    table->safi == SAFI_EVPN)
+			is_evpn = true;

 		if (BGP_DEBUG(zebra, ZEBRA))
 			zlog_debug(
@@ -1772,17 +1776,32 @@ static void bgp_handle_route_announcements_to_zebra(struct thread *e)
 				table->bgp->name_pretty, dest, dest->flags);

 		if (install) {
-			status = bgp_zebra_announce_actual(
-				dest, dest->za_bgp_pi, table->bgp);
+			if (is_evpn)
+				status = evpn_zebra_install(
+					table->bgp, dest->za_vpn,
+					(const struct prefix_evpn *)
+						bgp_dest_get_prefix(dest),
+					dest->za_bgp_pi);
+			else
+				status = bgp_zebra_announce_actual(
+					dest, dest->za_bgp_pi, table->bgp);
 			UNSET_FLAG(dest->flags, BGP_NODE_SCHEDULE_FOR_INSTALL);
 		} else {
-			status = bgp_zebra_withdraw_actual(
-				dest, dest->za_bgp_pi, table->bgp);
+			if (is_evpn)
+				status = evpn_zebra_uninstall(
+					table->bgp, dest->za_vpn,
+					(const struct prefix_evpn *)
+						bgp_dest_get_prefix(dest),
+					dest->za_bgp_pi, false);
+			else
+				status = bgp_zebra_withdraw_actual(
+					dest, dest->za_bgp_pi, table->bgp);
 			UNSET_FLAG(dest->flags, BGP_NODE_SCHEDULE_FOR_DELETE);
 		}

 		bgp_path_info_unlock(dest->za_bgp_pi);
 		dest->za_bgp_pi = NULL;
+		dest->za_vpn = NULL;
 		bgp_dest_unlock_node(dest);

 		if (status == ZCLIENT_SEND_BUFFERED)
@@ -1836,8 +1855,14 @@ static void bgp_zebra_buffer_write_ready(void)
  *                                     withdrawn.
  */
 void bgp_zebra_route_install(struct bgp_dest *dest, struct bgp_path_info *info,
-			     struct bgp *bgp, bool install)
+			     struct bgp *bgp, bool install, struct bgpevpn *vpn, bool is_sync)
 {
+	bool is_evpn = false;
+	struct bgp_table *table = NULL;
+
+	table = bgp_dest_table(dest);
+	if (table && table->afi == AFI_L2VPN && table->safi == SAFI_EVPN)
+		is_evpn = true;
 	/*
 	 * BGP is installing this route and bgp has been configured
 	 * to suppress announcements until the route has been installed
@@ -1847,7 +1872,7 @@ void bgp_zebra_route_install(struct bgp_dest *dest, struct bgp_path_info *info,
 		if (BGP_SUPPRESS_FIB_ENABLED(bgp))
 			SET_FLAG(dest->flags, BGP_NODE_FIB_INSTALL_PENDING);

-		if (bgp->main_zebra_update_hold)
+		if (bgp->main_zebra_update_hold && !is_evpn)
 			return;
 	} else {
 		UNSET_FLAG(dest->flags, BGP_NODE_FIB_INSTALL_PENDING);
@@ -1857,7 +1882,7 @@ void bgp_zebra_route_install(struct bgp_dest *dest, struct bgp_path_info *info,
 	 * Don't try to install if we're not connected to Zebra or Zebra doesn't
 	 * know of this instance.
 	 */
-	if (!bgp_install_info_to_zebra(bgp))
+	if (!bgp_install_info_to_zebra(bgp) && !is_evpn)
 		return;

 	if (!CHECK_FLAG(dest->flags, BGP_NODE_SCHEDULE_FOR_INSTALL) &&
@@ -1878,7 +1903,7 @@ void bgp_zebra_route_install(struct bgp_dest *dest, struct bgp_path_info *info,
 		dest->za_bgp_pi = info;
 	} else if (CHECK_FLAG(dest->flags, BGP_NODE_SCHEDULE_FOR_DELETE)) {
 		assert(dest->za_bgp_pi);
-		if (install)
+		if (install & !is_evpn)
 			bgp_zebra_withdraw_actual(dest, dest->za_bgp_pi, bgp);

 		bgp_path_info_unlock(dest->za_bgp_pi);
@@ -1886,6 +1911,11 @@ void bgp_zebra_route_install(struct bgp_dest *dest, struct bgp_path_info *info,
 		dest->za_bgp_pi = info;
 	}

+	if (is_evpn) {
+		dest->za_vpn = vpn;
+		dest->za_is_sync = is_sync;
+	}
+
 	if (install) {
 		UNSET_FLAG(dest->flags, BGP_NODE_SCHEDULE_FOR_DELETE);
 		SET_FLAG(dest->flags, BGP_NODE_SCHEDULE_FOR_INSTALL);
@@ -1916,7 +1946,7 @@ void bgp_zebra_withdraw_table_all_subtypes(struct bgp *bgp, afi_t afi, safi_t sa
 		for (pi = bgp_dest_get_bgp_path_info(dest); pi; pi = pi->next) {
 			if (CHECK_FLAG(pi->flags, BGP_PATH_SELECTED)
 			    && (pi->type == ZEBRA_ROUTE_BGP))
-				bgp_zebra_route_install(dest, pi, bgp, false);
+				bgp_zebra_route_install(dest, pi, bgp, false, NULL, false);
 		}
 	}
 }
diff --git a/bgpd/bgp_zebra.h b/bgpd/bgp_zebra.h
index 83197c28e..92971b51f 100644
--- a/bgpd/bgp_zebra.h
+++ b/bgpd/bgp_zebra.h
@@ -30,7 +30,7 @@ extern int bgp_zebra_get_table_range(struct zclient *zc, uint32_t chunk_size,
 extern int bgp_if_update_all(void);
 extern void bgp_zebra_route_install(struct bgp_dest *dest,
 				    struct bgp_path_info *path, struct bgp *bgp,
-				    bool install);
+				    bool install, struct bgpevpn *vpn, bool is_sync);

 extern void bgp_zebra_announce_table(struct bgp *bgp, afi_t afi, safi_t safi);
 extern enum zclient_send_status
diff --git a/bgpd/bgpd.h b/bgpd/bgpd.h
index a088a2e11..214a2f9b0 100644
--- a/bgpd/bgpd.h
+++ b/bgpd/bgpd.h
@@ -529,6 +529,7 @@ struct bgp {
 #define BGP_FLAG_LU_IPV6_EXPLICIT_NULL (1ULL << 34)
 #define BGP_FLAG_SOFT_VERSION_CAPABILITY (1ULL << 35)
 #define BGP_FLAG_ENFORCE_FIRST_AS (1ULL << 36)
+#define BGP_FLAG_VNI_DOWN (1ULL << 38)

 	/* BGP default address-families.
 	 * New peers inherit enabled afi/safis from bgp instance.
--
2.39.4

